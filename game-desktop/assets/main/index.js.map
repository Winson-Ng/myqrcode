{"version":3,"sources":["cce:/internal/cce:/internal/rollupPluginModLoBabelHelpers.js","file:/C:/ProgramData/cocos/editors/Creator/3.8.0/resources/resources/3d/engine/editor/assets/tools/file:/C:/ProgramData/cocos/editors/Creator/3.8.0/resources/resources/3d/engine/editor/assets/tools/debug-view-runtime-control.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/Enums.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/gameContext.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/bg.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/PhysicsObject.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/YMoveable.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/bullet.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/button.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/common/explosion.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/enemy.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/gameLevel.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/ui/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/ui/dialog.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/ui/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/ui/toast.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/weapon.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/player.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/gameManager.ts","file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/file:/C:/Users/WinsonWu/Projects/Skyfighter(2d)/Skyfighter/assets/scripts/home.ts"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","arg","key","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","String","Number","_toPrimitive","_createClass","Constructor","protoProps","staticProps","prototype","_inheritsLoose","subClass","superClass","create","constructor","_setPrototypeOf","o","p","setPrototypeOf","bind","__proto__","_assertThisInitialized","self","ReferenceError","_initializerDefineProperty","property","context","value","initializer","_applyDecoratedDescriptor","decorators","desc","keys","forEach","slice","reverse","reduce","decorator","ccclass","_decorator","_dec","_dec2","Node","_dec3","_dec4","_descriptor","_class2","_Component","DebugViewRuntimeControl","_this","_len","arguments","args","Array","_key","apply","concat","_descriptor2","_descriptor3","_single","strSingle","strComposite","strMisc","compositeModeToggleList","singleModeToggleList","miscModeToggleList","textComponentList","labelComponentList","textContentList","hideButtonLabel","_currentColorIndex","strColor","color","Color","WHITE","BLACK","RED","GREEN","BLUE","_proto","start","this","node","parent","getComponent","Canvas","uiTransform","UITransform","halfScreenWidth","width","halfScreenHeight","height","x","y","miscNode","getChildByName","buttonNode","instantiate","name","titleNode","newLabel","EnableAllCompositeModeButton","setPosition","setScale","labelComponent","Label","string","overflow","currentRow","newNode","singleModeToggle","textComponent","getComponentInChildren","RichText","on","Toggle","EventType","TOGGLE","toggleSingleMode","Button","CLICK","enableAllCompositeMode","changeColorButton","changeTextColor","HideButton","hideUI","compositeModeToggle","isChecked","toggleLightingWithAlbedo","toggleCSMColoration","toggleCompositeMode","console","error","isTextMatched","textUI","textDescription","tempText","findIndex","search","substr","toggle","debugView","director","root","singleMode","enableCompositeMode","lightingWithAlbedo","csmLayerColoration","button","toggleComponent","activeValue","active","onLoad","update","deltaTime","Component","_class","_RF","pop","MoveDirection","BulletTargetType","GameStatus","GameContext","presetMessages","gameStatus","Start","score","gameTime","life","lastEnemyTime","lastAwardTime","levelSetting","enemyInterval","enemyShootThreshold","enemyShootSpeed","enemyShootInterval","enemySpeed","awardInterval","levelUpScore","levelName","level","useGameLevel","reset","shouldCreateEnemy","shouldCreateAward","randomEnemyShoot","Math","random","get","_instance","bg","adjustLayout","contentSize","getScene","setContentSize","children","bgImg","scale","position","setSiblingIndex","getSiblingIndex","setBackGroundFrame","spriteFrame","Sprite","instance","Pause","clonedBgImg","bg1X","bg1Y","bg2X","bg2Y","PhysicsObject","_destoryCallback","sender","collider","Collider2D","Contact2DType","BEGIN_CONTACT","onCollisionEnter","END_CONTACT","onCollisionOut","other","set","YMoveable","type","Enum","_PhysicsObject","speed","targetXY","v3","fromPos","convertToWorldSpaceAR","screenWidth","screenHeight","direction","MoveUp","MoveDown","MoveXY","deltaX","abs","deltaY","distance","sqrt","destroy","Bullet","CCBoolean","_YMoveable","damage","useSkin","frame","hasAnimation","tween","repeatForever","by","ToEnemy","log","TOUCH_END","onBtnClick","e","loadScene","scene","Explosion","CCInteger","_this2","scheduleOnce","removeDelay","Enemy","Prefab","_dec5","bulletInterval","lastShootTime","_descriptor4","shoot","explosionPrefab","explosionNode","destoryCallback","bulletNode","bulletPrefab","bulletObj","bulletDamage","bulletSpeed","targetType","ToPlayer","GameLevel","CCFloat","_dec6","_dec7","_dec8","_dec9","_dec10","CCString","_dec11","SpriteFrame","_dec12","AudioClip","_descriptor5","_descriptor6","_descriptor7","_descriptor8","_descriptor9","_descriptor10","_descriptor11","Dialog","autoDismiss","pauseGame","buttons","show","title","message","Promise","resolve","reject","resources","load","err","prefab","dialog","dismiss","leftBtn","rightBtn","label","onLeftButtonClick","onRightButtonClick","action","val","messageNode","Toast","callback","messageLines","actualMessageLength","duration","playAnimation","lineIndex","str","sequence","to","easing","delay","_this3","split","l","trim","push","Weapon","removeFromParent","sound","AudioSourceComponent","play","Player","ProgressBar","bulletSetting","useWeapon","weapon","playerSpriteFrame","numberOfBullets","bulletSpriteFrame","progressBar","progress","_other$node$getCompon","Over","audioSource","addComponent","AudioSource","clip","pickupSound","defaultWeapon","Playing","playerSize","bulletRangeWidth","min","bullet","bulletComponent","bulletX","fireSound","_class3","GameManager","currentLevelIndex","beginingAnimation","beginingAnimationIsRunning","btnBack","lblScore","player","onBackBtnClick","readyGoSound","scoreAdd","gameLevels","changeGameLevel","levelIndex","levelPrefab","gameBgSpriteFrame","endGame","newScore","maxScoreNaN","parseInt","sys","localStorage","getItem","maxScore","isNaN","max","setItem","toString","randomIndex","floor","_this4","beginGameLevelIndex","PhysicsSystem2D","enable","isDebug","debugDrawFlags","EPhysics2DDrawFlags","All","None","isMobile","TOUCH_MOVE","onTouchMoveOfCanvas","onMouseMoveOfPlayer","stop","uiposition","getUILocation","newUILocation","convertToNodeSpaceAR","canvasSize","clamp","playerPos","delta","getDelta","newX","newY","cloneNode","renderAwards","weaponTypes","round","awardPrefab","award","awardObj","canvas","screen","awardWidth","awardHeight","awardX","awardY","renderEnemies","_this5","enemy","enemyPrefab","enemyObj","enemyWidth","enemyHeight","enemyX","enemyY","home","startButton","onStartButtonClick"],"mappings":"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","file":"all.js","sourcesContent":["export { _AsyncGenerator as AsyncGenerator, _OverloadYield as OverloadYield, _applyDecs as applyDecs, _applyDecs2203 as applyDecs2203, _applyDecs2203R as applyDecs2203R, _applyDecs2301 as applyDecs2301, _applyDecs2305 as applyDecs2305, _asyncGeneratorDelegate as asyncGeneratorDelegate, _asyncIterator as asyncIterator, _awaitAsyncGenerator as awaitAsyncGenerator, _checkInRHS as checkInRHS, _defineAccessor as defineAccessor, _dispose as dispose, _iterableToArrayLimit as iterableToArrayLimit, _iterableToArrayLimitLoose as iterableToArrayLimitLoose, _jsx as jsx, _objectSpread2 as objectSpread2, _regeneratorRuntime as regeneratorRuntime, _typeof as typeof, _using as using, _wrapRegExp as wrapRegExp, _AwaitValue as AwaitValue, _wrapAsyncGenerator as wrapAsyncGenerator, _asyncToGenerator as asyncToGenerator, _classCallCheck as classCallCheck, _createClass as createClass, _defineEnumerableProperties as defineEnumerableProperties, _defaults as defaults, _defineProperty as defineProperty, _extends as extends, _objectSpread as objectSpread, _inherits as inherits, _inheritsLoose as inheritsLoose, _getPrototypeOf as getPrototypeOf, _setPrototypeOf as setPrototypeOf, _isNativeReflectConstruct as isNativeReflectConstruct, _construct as construct, _isNativeFunction as isNativeFunction, _wrapNativeSuper as wrapNativeSuper, _instanceof as instanceof, _interopRequireDefault as interopRequireDefault, _interopRequireWildcard as interopRequireWildcard, _newArrowCheck as newArrowCheck, _objectDestructuringEmpty as objectDestructuringEmpty, _objectWithoutPropertiesLoose as objectWithoutPropertiesLoose, _objectWithoutProperties as objectWithoutProperties, _assertThisInitialized as assertThisInitialized, _possibleConstructorReturn as possibleConstructorReturn, _createSuper as createSuper, _superPropBase as superPropBase, _get as get, _set as set, _taggedTemplateLiteral as taggedTemplateLiteral, _taggedTemplateLiteralLoose as taggedTemplateLiteralLoose, _readOnlyError as readOnlyError, _writeOnlyError as writeOnlyError, _classNameTDZError as classNameTDZError, _temporalUndefined as temporalUndefined, _tdz as tdz, _temporalRef as temporalRef, _slicedToArray as slicedToArray, _slicedToArrayLoose as slicedToArrayLoose, _toArray as toArray, _toConsumableArray as toConsumableArray, _arrayWithoutHoles as arrayWithoutHoles, _arrayWithHoles as arrayWithHoles, _maybeArrayLike as maybeArrayLike, _iterableToArray as iterableToArray, _unsupportedIterableToArray as unsupportedIterableToArray, _arrayLikeToArray as arrayLikeToArray, _nonIterableSpread as nonIterableSpread, _nonIterableRest as nonIterableRest, _createForOfIteratorHelper as createForOfIteratorHelper, _createForOfIteratorHelperLoose as createForOfIteratorHelperLoose, _skipFirstGeneratorNext as skipFirstGeneratorNext, _toPrimitive as toPrimitive, _toPropertyKey as toPropertyKey, _initializerWarningHelper as initializerWarningHelper, _initializerDefineProperty as initializerDefineProperty, _applyDecoratedDescriptor as applyDecoratedDescriptor, _classPrivateFieldLooseKey as classPrivateFieldLooseKey, _classPrivateFieldLooseBase as classPrivateFieldLooseBase, _classPrivateFieldGet as classPrivateFieldGet, _classPrivateFieldSet as classPrivateFieldSet, _classPrivateFieldDestructureSet as classPrivateFieldDestructureSet, _classExtractFieldDescriptor as classExtractFieldDescriptor, _classStaticPrivateFieldSpecGet as classStaticPrivateFieldSpecGet, _classStaticPrivateFieldSpecSet as classStaticPrivateFieldSpecSet, _classStaticPrivateMethodGet as classStaticPrivateMethodGet, _classStaticPrivateMethodSet as classStaticPrivateMethodSet, _classApplyDescriptorGet as classApplyDescriptorGet, _classApplyDescriptorSet as classApplyDescriptorSet, _classApplyDescriptorDestructureSet as classApplyDescriptorDestructureSet, _classStaticPrivateFieldDestructureSet as classStaticPrivateFieldDestructureSet, _classCheckPrivateStaticAccess as classCheckPrivateStaticAccess, _classCheckPrivateStaticFieldDescriptor as classCheckPrivateStaticFieldDescriptor, _decorate as decorate, _classPrivateMethodGet as classPrivateMethodGet, _checkPrivateRedeclaration as checkPrivateRedeclaration, _classPrivateFieldInitSpec as classPrivateFieldInitSpec, _classPrivateMethodInitSpec as classPrivateMethodInitSpec, _classPrivateMethodSet as classPrivateMethodSet, _identity as identity };\nfunction _AsyncGenerator(gen) {\n  var front, back;\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg),\n        value = result.value,\n        overloaded = value instanceof _OverloadYield;\n      Promise.resolve(overloaded ? value.v : value).then(function (arg) {\n        if (overloaded) {\n          var nextKey = \"return\" === key ? \"return\" : \"next\";\n          if (!value.k || arg.done) return resume(nextKey, arg);\n          arg = gen[nextKey](arg).value;\n        }\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        front.reject(value);\n        break;\n      default:\n        front.resolve({\n          value: value,\n          done: !1\n        });\n    }\n    (front = front.next) ? resume(front.key, front.arg) : back = null;\n  }\n  this._invoke = function (key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n      back ? back = back.next = request : (front = back = request, resume(key, arg));\n    });\n  }, \"function\" != typeof gen.return && (this.return = void 0);\n}\n_AsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, _AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n}, _AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n}, _AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\nfunction _OverloadYield(value, kind) {\n  this.v = value, this.k = kind;\n}\nfunction old_createMetadataMethodsForProperty(metadataMap, kind, property, decoratorFinishedRef) {\n  return {\n    getMetadata: function (key) {\n      old_assertNotFinished(decoratorFinishedRef, \"getMetadata\"), old_assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n      if (void 0 !== metadataForKey) if (1 === kind) {\n        var pub = metadataForKey.public;\n        if (void 0 !== pub) return pub[property];\n      } else if (2 === kind) {\n        var priv = metadataForKey.private;\n        if (void 0 !== priv) return priv.get(property);\n      } else if (Object.hasOwnProperty.call(metadataForKey, \"constructor\")) return metadataForKey.constructor;\n    },\n    setMetadata: function (key, value) {\n      old_assertNotFinished(decoratorFinishedRef, \"setMetadata\"), old_assertMetadataKey(key);\n      var metadataForKey = metadataMap[key];\n      if (void 0 === metadataForKey && (metadataForKey = metadataMap[key] = {}), 1 === kind) {\n        var pub = metadataForKey.public;\n        void 0 === pub && (pub = metadataForKey.public = {}), pub[property] = value;\n      } else if (2 === kind) {\n        var priv = metadataForKey.priv;\n        void 0 === priv && (priv = metadataForKey.private = new Map()), priv.set(property, value);\n      } else metadataForKey.constructor = value;\n    }\n  };\n}\nfunction old_convertMetadataMapToFinal(obj, metadataMap) {\n  var parentMetadataMap = obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")],\n    metadataKeys = Object.getOwnPropertySymbols(metadataMap);\n  if (0 !== metadataKeys.length) {\n    for (var i = 0; i < metadataKeys.length; i++) {\n      var key = metadataKeys[i],\n        metaForKey = metadataMap[key],\n        parentMetaForKey = parentMetadataMap ? parentMetadataMap[key] : null,\n        pub = metaForKey.public,\n        parentPub = parentMetaForKey ? parentMetaForKey.public : null;\n      pub && parentPub && Object.setPrototypeOf(pub, parentPub);\n      var priv = metaForKey.private;\n      if (priv) {\n        var privArr = Array.from(priv.values()),\n          parentPriv = parentMetaForKey ? parentMetaForKey.private : null;\n        parentPriv && (privArr = privArr.concat(parentPriv)), metaForKey.private = privArr;\n      }\n      parentMetaForKey && Object.setPrototypeOf(metaForKey, parentMetaForKey);\n    }\n    parentMetadataMap && Object.setPrototypeOf(metadataMap, parentMetadataMap), obj[Symbol.metadata || Symbol.for(\"Symbol.metadata\")] = metadataMap;\n  }\n}\nfunction old_createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function (initializer) {\n    old_assertNotFinished(decoratorFinishedRef, \"addInitializer\"), old_assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n  };\n}\nfunction old_memberDec(dec, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value) {\n  var kindStr;\n  switch (kind) {\n    case 1:\n      kindStr = \"accessor\";\n      break;\n    case 2:\n      kindStr = \"method\";\n      break;\n    case 3:\n      kindStr = \"getter\";\n      break;\n    case 4:\n      kindStr = \"setter\";\n      break;\n    default:\n      kindStr = \"field\";\n  }\n  var metadataKind,\n    metadataName,\n    ctx = {\n      kind: kindStr,\n      name: isPrivate ? \"#\" + name : name,\n      isStatic: isStatic,\n      isPrivate: isPrivate\n    },\n    decoratorFinishedRef = {\n      v: !1\n    };\n  if (0 !== kind && (ctx.addInitializer = old_createAddInitializerMethod(initializers, decoratorFinishedRef)), isPrivate) {\n    metadataKind = 2, metadataName = Symbol(name);\n    var access = {};\n    0 === kind ? (access.get = desc.get, access.set = desc.set) : 2 === kind ? access.get = function () {\n      return desc.value;\n    } : (1 !== kind && 3 !== kind || (access.get = function () {\n      return desc.get.call(this);\n    }), 1 !== kind && 4 !== kind || (access.set = function (v) {\n      desc.set.call(this, v);\n    })), ctx.access = access;\n  } else metadataKind = 1, metadataName = name;\n  try {\n    return dec(value, Object.assign(ctx, old_createMetadataMethodsForProperty(metadataMap, metadataKind, metadataName, decoratorFinishedRef)));\n  } finally {\n    decoratorFinishedRef.v = !0;\n  }\n}\nfunction old_assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n}\nfunction old_assertMetadataKey(key) {\n  if (\"symbol\" != typeof key) throw new TypeError(\"Metadata keys must be symbols, received: \" + key);\n}\nfunction old_assertCallable(fn, hint) {\n  if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n}\nfunction old_assertValidReturnValue(kind, value) {\n  var type = typeof value;\n  if (1 === kind) {\n    if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n    void 0 !== value.get && old_assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && old_assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && old_assertCallable(value.init, \"accessor.init\"), void 0 !== value.initializer && old_assertCallable(value.initializer, \"accessor.initializer\");\n  } else if (\"function\" !== type) {\n    var hint;\n    throw hint = 0 === kind ? \"field\" : 10 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n  }\n}\nfunction old_getInit(desc) {\n  var initializer;\n  return null == (initializer = desc.init) && (initializer = desc.initializer) && \"undefined\" != typeof console && console.warn(\".initializer has been renamed to .init as of March 2022\"), initializer;\n}\nfunction old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers) {\n  var desc,\n    initializer,\n    value,\n    newValue,\n    get,\n    set,\n    decs = decInfo[0];\n  if (isPrivate ? desc = 0 === kind || 1 === kind ? {\n    get: decInfo[3],\n    set: decInfo[4]\n  } : 3 === kind ? {\n    get: decInfo[3]\n  } : 4 === kind ? {\n    set: decInfo[3]\n  } : {\n    value: decInfo[3]\n  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n    get: desc.get,\n    set: desc.set\n  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), \"function\" == typeof decs) void 0 !== (newValue = old_memberDec(decs, name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value)) && (old_assertValidReturnValue(kind, newValue), 0 === kind ? initializer = newValue : 1 === kind ? (initializer = old_getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {\n    get: get,\n    set: set\n  }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {\n    var newInit;\n    if (void 0 !== (newValue = old_memberDec(decs[i], name, desc, metadataMap, initializers, kind, isStatic, isPrivate, value))) old_assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = old_getInit(newValue), get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue, void 0 !== newInit && (void 0 === initializer ? initializer = newInit : \"function\" == typeof initializer ? initializer = [initializer, newInit] : initializer.push(newInit));\n  }\n  if (0 === kind || 1 === kind) {\n    if (void 0 === initializer) initializer = function (instance, init) {\n      return init;\n    };else if (\"function\" != typeof initializer) {\n      var ownInitializers = initializer;\n      initializer = function (instance, init) {\n        for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n        return value;\n      };\n    } else {\n      var originalInitializer = initializer;\n      initializer = function (instance, init) {\n        return originalInitializer.call(instance, init);\n      };\n    }\n    ret.push(initializer);\n  }\n  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n    return value.get.call(instance, args);\n  }), ret.push(function (instance, args) {\n    return value.set.call(instance, args);\n  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n    return value.call(instance, args);\n  }) : Object.defineProperty(base, name, desc));\n}\nfunction old_applyMemberDecs(ret, Class, protoMetadataMap, staticMetadataMap, decInfos) {\n  for (var protoInitializers, staticInitializers, existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n    var decInfo = decInfos[i];\n    if (Array.isArray(decInfo)) {\n      var base,\n        metadataMap,\n        initializers,\n        kind = decInfo[1],\n        name = decInfo[2],\n        isPrivate = decInfo.length > 3,\n        isStatic = kind >= 5;\n      if (isStatic ? (base = Class, metadataMap = staticMetadataMap, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, metadataMap = protoMetadataMap, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n          existingKind = existingNonFields.get(name) || 0;\n        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n        !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);\n      }\n      old_applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, metadataMap, initializers);\n    }\n  }\n  old_pushInitializers(ret, protoInitializers), old_pushInitializers(ret, staticInitializers);\n}\nfunction old_pushInitializers(ret, initializers) {\n  initializers && ret.push(function (instance) {\n    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n    return instance;\n  });\n}\nfunction old_applyClassDecs(ret, targetClass, metadataMap, classDecs) {\n  if (classDecs.length > 0) {\n    for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {\n      var decoratorFinishedRef = {\n        v: !1\n      };\n      try {\n        var ctx = Object.assign({\n            kind: \"class\",\n            name: name,\n            addInitializer: old_createAddInitializerMethod(initializers, decoratorFinishedRef)\n          }, old_createMetadataMethodsForProperty(metadataMap, 0, name, decoratorFinishedRef)),\n          nextNewClass = classDecs[i](newClass, ctx);\n      } finally {\n        decoratorFinishedRef.v = !0;\n      }\n      void 0 !== nextNewClass && (old_assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);\n    }\n    ret.push(newClass, function () {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n    });\n  }\n}\nfunction _applyDecs(targetClass, memberDecs, classDecs) {\n  var ret = [],\n    staticMetadataMap = {},\n    protoMetadataMap = {};\n  return old_applyMemberDecs(ret, targetClass, protoMetadataMap, staticMetadataMap, memberDecs), old_convertMetadataMapToFinal(targetClass.prototype, protoMetadataMap), old_applyClassDecs(ret, targetClass, staticMetadataMap, classDecs), old_convertMetadataMapToFinal(targetClass, staticMetadataMap), ret;\n}\nfunction applyDecs2203Factory() {\n  function createAddInitializerMethod(initializers, decoratorFinishedRef) {\n    return function (initializer) {\n      !function (decoratorFinishedRef, fnName) {\n        if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n      }(decoratorFinishedRef, \"addInitializer\"), assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n    };\n  }\n  function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value) {\n    var kindStr;\n    switch (kind) {\n      case 1:\n        kindStr = \"accessor\";\n        break;\n      case 2:\n        kindStr = \"method\";\n        break;\n      case 3:\n        kindStr = \"getter\";\n        break;\n      case 4:\n        kindStr = \"setter\";\n        break;\n      default:\n        kindStr = \"field\";\n    }\n    var get,\n      set,\n      ctx = {\n        kind: kindStr,\n        name: isPrivate ? \"#\" + name : name,\n        static: isStatic,\n        private: isPrivate\n      },\n      decoratorFinishedRef = {\n        v: !1\n      };\n    0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), 0 === kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = function () {\n      return this[name];\n    }, set = function (v) {\n      this[name] = v;\n    }) : 2 === kind ? get = function () {\n      return desc.value;\n    } : (1 !== kind && 3 !== kind || (get = function () {\n      return desc.get.call(this);\n    }), 1 !== kind && 4 !== kind || (set = function (v) {\n      desc.set.call(this, v);\n    })), ctx.access = get && set ? {\n      get: get,\n      set: set\n    } : get ? {\n      get: get\n    } : {\n      set: set\n    };\n    try {\n      return dec(value, ctx);\n    } finally {\n      decoratorFinishedRef.v = !0;\n    }\n  }\n  function assertCallable(fn, hint) {\n    if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n  }\n  function assertValidReturnValue(kind, value) {\n    var type = typeof value;\n    if (1 === kind) {\n      if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n      void 0 !== value.get && assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && assertCallable(value.init, \"accessor.init\");\n    } else if (\"function\" !== type) {\n      var hint;\n      throw hint = 0 === kind ? \"field\" : 10 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n    }\n  }\n  function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers) {\n    var desc,\n      init,\n      value,\n      newValue,\n      get,\n      set,\n      decs = decInfo[0];\n    if (isPrivate ? desc = 0 === kind || 1 === kind ? {\n      get: decInfo[3],\n      set: decInfo[4]\n    } : 3 === kind ? {\n      get: decInfo[3]\n    } : 4 === kind ? {\n      set: decInfo[3]\n    } : {\n      value: decInfo[3]\n    } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n      get: desc.get,\n      set: desc.set\n    } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), \"function\" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {\n      var newInit;\n      if (void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, value))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n        get: get,\n        set: set\n      }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : \"function\" == typeof init ? init = [init, newInit] : init.push(newInit));\n    }\n    if (0 === kind || 1 === kind) {\n      if (void 0 === init) init = function (instance, init) {\n        return init;\n      };else if (\"function\" != typeof init) {\n        var ownInitializers = init;\n        init = function (instance, init) {\n          for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n          return value;\n        };\n      } else {\n        var originalInitializer = init;\n        init = function (instance, init) {\n          return originalInitializer.call(instance, init);\n        };\n      }\n      ret.push(init);\n    }\n    0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n      return value.get.call(instance, args);\n    }), ret.push(function (instance, args) {\n      return value.set.call(instance, args);\n    })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n      return value.call(instance, args);\n    }) : Object.defineProperty(base, name, desc));\n  }\n  function pushInitializers(ret, initializers) {\n    initializers && ret.push(function (instance) {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n      return instance;\n    });\n  }\n  return function (targetClass, memberDecs, classDecs) {\n    var ret = [];\n    return function (ret, Class, decInfos) {\n      for (var protoInitializers, staticInitializers, existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n        var decInfo = decInfos[i];\n        if (Array.isArray(decInfo)) {\n          var base,\n            initializers,\n            kind = decInfo[1],\n            name = decInfo[2],\n            isPrivate = decInfo.length > 3,\n            isStatic = kind >= 5;\n          if (isStatic ? (base = Class, 0 != (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n            var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n              existingKind = existingNonFields.get(name) || 0;\n            if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n            !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);\n          }\n          applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers);\n        }\n      }\n      pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers);\n    }(ret, targetClass, memberDecs), function (ret, targetClass, classDecs) {\n      if (classDecs.length > 0) {\n        for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {\n          var decoratorFinishedRef = {\n            v: !1\n          };\n          try {\n            var nextNewClass = classDecs[i](newClass, {\n              kind: \"class\",\n              name: name,\n              addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)\n            });\n          } finally {\n            decoratorFinishedRef.v = !0;\n          }\n          void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);\n        }\n        ret.push(newClass, function () {\n          for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n        });\n      }\n    }(ret, targetClass, classDecs), ret;\n  };\n}\nvar applyDecs2203Impl;\nfunction _applyDecs2203(targetClass, memberDecs, classDecs) {\n  return (applyDecs2203Impl = applyDecs2203Impl || applyDecs2203Factory())(targetClass, memberDecs, classDecs);\n}\nfunction applyDecs2203RFactory() {\n  function createAddInitializerMethod(initializers, decoratorFinishedRef) {\n    return function (initializer) {\n      !function (decoratorFinishedRef, fnName) {\n        if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n      }(decoratorFinishedRef, \"addInitializer\"), assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n    };\n  }\n  function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value) {\n    var kindStr;\n    switch (kind) {\n      case 1:\n        kindStr = \"accessor\";\n        break;\n      case 2:\n        kindStr = \"method\";\n        break;\n      case 3:\n        kindStr = \"getter\";\n        break;\n      case 4:\n        kindStr = \"setter\";\n        break;\n      default:\n        kindStr = \"field\";\n    }\n    var get,\n      set,\n      ctx = {\n        kind: kindStr,\n        name: isPrivate ? \"#\" + name : name,\n        static: isStatic,\n        private: isPrivate\n      },\n      decoratorFinishedRef = {\n        v: !1\n      };\n    0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), 0 === kind ? isPrivate ? (get = desc.get, set = desc.set) : (get = function () {\n      return this[name];\n    }, set = function (v) {\n      this[name] = v;\n    }) : 2 === kind ? get = function () {\n      return desc.value;\n    } : (1 !== kind && 3 !== kind || (get = function () {\n      return desc.get.call(this);\n    }), 1 !== kind && 4 !== kind || (set = function (v) {\n      desc.set.call(this, v);\n    })), ctx.access = get && set ? {\n      get: get,\n      set: set\n    } : get ? {\n      get: get\n    } : {\n      set: set\n    };\n    try {\n      return dec(value, ctx);\n    } finally {\n      decoratorFinishedRef.v = !0;\n    }\n  }\n  function assertCallable(fn, hint) {\n    if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n  }\n  function assertValidReturnValue(kind, value) {\n    var type = typeof value;\n    if (1 === kind) {\n      if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n      void 0 !== value.get && assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && assertCallable(value.init, \"accessor.init\");\n    } else if (\"function\" !== type) {\n      var hint;\n      throw hint = 0 === kind ? \"field\" : 10 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n    }\n  }\n  function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers) {\n    var desc,\n      init,\n      value,\n      newValue,\n      get,\n      set,\n      decs = decInfo[0];\n    if (isPrivate ? desc = 0 === kind || 1 === kind ? {\n      get: decInfo[3],\n      set: decInfo[4]\n    } : 3 === kind ? {\n      get: decInfo[3]\n    } : 4 === kind ? {\n      set: decInfo[3]\n    } : {\n      value: decInfo[3]\n    } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n      get: desc.get,\n      set: desc.set\n    } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), \"function\" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, value)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {\n      var newInit;\n      if (void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, value))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n        get: get,\n        set: set\n      }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : \"function\" == typeof init ? init = [init, newInit] : init.push(newInit));\n    }\n    if (0 === kind || 1 === kind) {\n      if (void 0 === init) init = function (instance, init) {\n        return init;\n      };else if (\"function\" != typeof init) {\n        var ownInitializers = init;\n        init = function (instance, init) {\n          for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n          return value;\n        };\n      } else {\n        var originalInitializer = init;\n        init = function (instance, init) {\n          return originalInitializer.call(instance, init);\n        };\n      }\n      ret.push(init);\n    }\n    0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n      return value.get.call(instance, args);\n    }), ret.push(function (instance, args) {\n      return value.set.call(instance, args);\n    })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n      return value.call(instance, args);\n    }) : Object.defineProperty(base, name, desc));\n  }\n  function applyMemberDecs(Class, decInfos) {\n    for (var protoInitializers, staticInitializers, ret = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n      var decInfo = decInfos[i];\n      if (Array.isArray(decInfo)) {\n        var base,\n          initializers,\n          kind = decInfo[1],\n          name = decInfo[2],\n          isPrivate = decInfo.length > 3,\n          isStatic = kind >= 5;\n        if (isStatic ? (base = Class, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || [])) : (base = Class.prototype, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n          var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n            existingKind = existingNonFields.get(name) || 0;\n          if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n          !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);\n        }\n        applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers);\n      }\n    }\n    return pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;\n  }\n  function pushInitializers(ret, initializers) {\n    initializers && ret.push(function (instance) {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n      return instance;\n    });\n  }\n  return function (targetClass, memberDecs, classDecs) {\n    return {\n      e: applyMemberDecs(targetClass, memberDecs),\n      get c() {\n        return function (targetClass, classDecs) {\n          if (classDecs.length > 0) {\n            for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {\n              var decoratorFinishedRef = {\n                v: !1\n              };\n              try {\n                var nextNewClass = classDecs[i](newClass, {\n                  kind: \"class\",\n                  name: name,\n                  addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)\n                });\n              } finally {\n                decoratorFinishedRef.v = !0;\n              }\n              void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);\n            }\n            return [newClass, function () {\n              for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n            }];\n          }\n        }(targetClass, classDecs);\n      }\n    };\n  };\n}\nfunction _applyDecs2203R(targetClass, memberDecs, classDecs) {\n  return (_applyDecs2203R = applyDecs2203RFactory())(targetClass, memberDecs, classDecs);\n}\nfunction applyDecs2301Factory() {\n  function createAddInitializerMethod(initializers, decoratorFinishedRef) {\n    return function (initializer) {\n      !function (decoratorFinishedRef, fnName) {\n        if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n      }(decoratorFinishedRef, \"addInitializer\"), assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n    };\n  }\n  function assertInstanceIfPrivate(has, target) {\n    if (!has(target)) throw new TypeError(\"Attempted to access private element on non-instance\");\n  }\n  function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand) {\n    var kindStr;\n    switch (kind) {\n      case 1:\n        kindStr = \"accessor\";\n        break;\n      case 2:\n        kindStr = \"method\";\n        break;\n      case 3:\n        kindStr = \"getter\";\n        break;\n      case 4:\n        kindStr = \"setter\";\n        break;\n      default:\n        kindStr = \"field\";\n    }\n    var get,\n      set,\n      ctx = {\n        kind: kindStr,\n        name: isPrivate ? \"#\" + name : name,\n        static: isStatic,\n        private: isPrivate\n      },\n      decoratorFinishedRef = {\n        v: !1\n      };\n    if (0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), isPrivate || 0 !== kind && 2 !== kind) {\n      if (2 === kind) get = function (target) {\n        return assertInstanceIfPrivate(hasPrivateBrand, target), desc.value;\n      };else {\n        var t = 0 === kind || 1 === kind;\n        (t || 3 === kind) && (get = isPrivate ? function (target) {\n          return assertInstanceIfPrivate(hasPrivateBrand, target), desc.get.call(target);\n        } : function (target) {\n          return desc.get.call(target);\n        }), (t || 4 === kind) && (set = isPrivate ? function (target, value) {\n          assertInstanceIfPrivate(hasPrivateBrand, target), desc.set.call(target, value);\n        } : function (target, value) {\n          desc.set.call(target, value);\n        });\n      }\n    } else get = function (target) {\n      return target[name];\n    }, 0 === kind && (set = function (target, v) {\n      target[name] = v;\n    });\n    var has = isPrivate ? hasPrivateBrand.bind() : function (target) {\n      return name in target;\n    };\n    ctx.access = get && set ? {\n      get: get,\n      set: set,\n      has: has\n    } : get ? {\n      get: get,\n      has: has\n    } : {\n      set: set,\n      has: has\n    };\n    try {\n      return dec(value, ctx);\n    } finally {\n      decoratorFinishedRef.v = !0;\n    }\n  }\n  function assertCallable(fn, hint) {\n    if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n  }\n  function assertValidReturnValue(kind, value) {\n    var type = typeof value;\n    if (1 === kind) {\n      if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n      void 0 !== value.get && assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && assertCallable(value.init, \"accessor.init\");\n    } else if (\"function\" !== type) {\n      var hint;\n      throw hint = 0 === kind ? \"field\" : 10 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n    }\n  }\n  function curryThis2(fn) {\n    return function (value) {\n      fn(this, value);\n    };\n  }\n  function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand) {\n    var desc,\n      init,\n      value,\n      fn,\n      newValue,\n      get,\n      set,\n      decs = decInfo[0];\n    if (isPrivate ? desc = 0 === kind || 1 === kind ? {\n      get: (fn = decInfo[3], function () {\n        return fn(this);\n      }),\n      set: curryThis2(decInfo[4])\n    } : 3 === kind ? {\n      get: decInfo[3]\n    } : 4 === kind ? {\n      set: decInfo[3]\n    } : {\n      value: decInfo[3]\n    } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n      get: desc.get,\n      set: desc.set\n    } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set), \"function\" == typeof decs) void 0 !== (newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand)) && (assertValidReturnValue(kind, newValue), 0 === kind ? init = newValue : 1 === kind ? (init = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue);else for (var i = decs.length - 1; i >= 0; i--) {\n      var newInit;\n      if (void 0 !== (newValue = memberDec(decs[i], name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n        get: get,\n        set: set\n      }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : \"function\" == typeof init ? init = [init, newInit] : init.push(newInit));\n    }\n    if (0 === kind || 1 === kind) {\n      if (void 0 === init) init = function (instance, init) {\n        return init;\n      };else if (\"function\" != typeof init) {\n        var ownInitializers = init;\n        init = function (instance, init) {\n          for (var value = init, i = 0; i < ownInitializers.length; i++) value = ownInitializers[i].call(instance, value);\n          return value;\n        };\n      } else {\n        var originalInitializer = init;\n        init = function (instance, init) {\n          return originalInitializer.call(instance, init);\n        };\n      }\n      ret.push(init);\n    }\n    0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n      return value.get.call(instance, args);\n    }), ret.push(function (instance, args) {\n      return value.set.call(instance, args);\n    })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n      return value.call(instance, args);\n    }) : Object.defineProperty(base, name, desc));\n  }\n  function applyMemberDecs(Class, decInfos, instanceBrand) {\n    for (var protoInitializers, staticInitializers, staticBrand, ret = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n      var decInfo = decInfos[i];\n      if (Array.isArray(decInfo)) {\n        var base,\n          initializers,\n          kind = decInfo[1],\n          name = decInfo[2],\n          isPrivate = decInfo.length > 3,\n          isStatic = kind >= 5,\n          hasPrivateBrand = instanceBrand;\n        if (isStatic ? (base = Class, 0 !== (kind -= 5) && (initializers = staticInitializers = staticInitializers || []), isPrivate && !staticBrand && (staticBrand = function (_) {\n          return _checkInRHS(_) === Class;\n        }), hasPrivateBrand = staticBrand) : (base = Class.prototype, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n          var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n            existingKind = existingNonFields.get(name) || 0;\n          if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n          !existingKind && kind > 2 ? existingNonFields.set(name, kind) : existingNonFields.set(name, !0);\n        }\n        applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand);\n      }\n    }\n    return pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;\n  }\n  function pushInitializers(ret, initializers) {\n    initializers && ret.push(function (instance) {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n      return instance;\n    });\n  }\n  return function (targetClass, memberDecs, classDecs, instanceBrand) {\n    return {\n      e: applyMemberDecs(targetClass, memberDecs, instanceBrand),\n      get c() {\n        return function (targetClass, classDecs) {\n          if (classDecs.length > 0) {\n            for (var initializers = [], newClass = targetClass, name = targetClass.name, i = classDecs.length - 1; i >= 0; i--) {\n              var decoratorFinishedRef = {\n                v: !1\n              };\n              try {\n                var nextNewClass = classDecs[i](newClass, {\n                  kind: \"class\",\n                  name: name,\n                  addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)\n                });\n              } finally {\n                decoratorFinishedRef.v = !0;\n              }\n              void 0 !== nextNewClass && (assertValidReturnValue(10, nextNewClass), newClass = nextNewClass);\n            }\n            return [newClass, function () {\n              for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n            }];\n          }\n        }(targetClass, classDecs);\n      }\n    };\n  };\n}\nfunction _applyDecs2301(targetClass, memberDecs, classDecs, instanceBrand) {\n  return (_applyDecs2301 = applyDecs2301Factory())(targetClass, memberDecs, classDecs, instanceBrand);\n}\nfunction createAddInitializerMethod(initializers, decoratorFinishedRef) {\n  return function (initializer) {\n    assertNotFinished(decoratorFinishedRef, \"addInitializer\"), assertCallable(initializer, \"An initializer\"), initializers.push(initializer);\n  };\n}\nfunction assertInstanceIfPrivate(has, target) {\n  if (!has(target)) throw new TypeError(\"Attempted to access private element on non-instance\");\n}\nfunction memberDec(dec, thisArg, name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand) {\n  var kindStr;\n  switch (kind) {\n    case 1:\n      kindStr = \"accessor\";\n      break;\n    case 2:\n      kindStr = \"method\";\n      break;\n    case 3:\n      kindStr = \"getter\";\n      break;\n    case 4:\n      kindStr = \"setter\";\n      break;\n    default:\n      kindStr = \"field\";\n  }\n  var get,\n    set,\n    ctx = {\n      kind: kindStr,\n      name: isPrivate ? \"#\" + name : name,\n      static: isStatic,\n      private: isPrivate\n    },\n    decoratorFinishedRef = {\n      v: !1\n    };\n  if (0 !== kind && (ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef)), isPrivate || 0 !== kind && 2 !== kind) {\n    if (2 === kind) get = function (target) {\n      return assertInstanceIfPrivate(hasPrivateBrand, target), desc.value;\n    };else {\n      var t = 0 === kind || 1 === kind;\n      (t || 3 === kind) && (get = isPrivate ? function (target) {\n        return assertInstanceIfPrivate(hasPrivateBrand, target), desc.get.call(target);\n      } : function (target) {\n        return desc.get.call(target);\n      }), (t || 4 === kind) && (set = isPrivate ? function (target, value) {\n        assertInstanceIfPrivate(hasPrivateBrand, target), desc.set.call(target, value);\n      } : function (target, value) {\n        desc.set.call(target, value);\n      });\n    }\n  } else get = function (target) {\n    return target[name];\n  }, 0 === kind && (set = function (target, v) {\n    target[name] = v;\n  });\n  var has = isPrivate ? hasPrivateBrand.bind() : function (target) {\n    return name in target;\n  };\n  ctx.access = get && set ? {\n    get: get,\n    set: set,\n    has: has\n  } : get ? {\n    get: get,\n    has: has\n  } : {\n    set: set,\n    has: has\n  };\n  try {\n    return dec.call(thisArg, value, ctx);\n  } finally {\n    decoratorFinishedRef.v = !0;\n  }\n}\nfunction assertNotFinished(decoratorFinishedRef, fnName) {\n  if (decoratorFinishedRef.v) throw new Error(\"attempted to call \" + fnName + \" after decoration was finished\");\n}\nfunction assertCallable(fn, hint) {\n  if (\"function\" != typeof fn) throw new TypeError(hint + \" must be a function\");\n}\nfunction assertValidReturnValue(kind, value) {\n  var type = typeof value;\n  if (1 === kind) {\n    if (\"object\" !== type || null === value) throw new TypeError(\"accessor decorators must return an object with get, set, or init properties or void 0\");\n    void 0 !== value.get && assertCallable(value.get, \"accessor.get\"), void 0 !== value.set && assertCallable(value.set, \"accessor.set\"), void 0 !== value.init && assertCallable(value.init, \"accessor.init\");\n  } else if (\"function\" !== type) {\n    var hint;\n    throw hint = 0 === kind ? \"field\" : 5 === kind ? \"class\" : \"method\", new TypeError(hint + \" decorators must return a function or void 0\");\n  }\n}\nfunction curryThis1(fn) {\n  return function () {\n    return fn(this);\n  };\n}\nfunction curryThis2(fn) {\n  return function (value) {\n    fn(this, value);\n  };\n}\nfunction applyMemberDec(ret, base, decInfo, decoratorsHaveThis, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand) {\n  var desc,\n    init,\n    value,\n    newValue,\n    get,\n    set,\n    decs = decInfo[0];\n  decoratorsHaveThis || Array.isArray(decs) || (decs = [decs]), isPrivate ? desc = 0 === kind || 1 === kind ? {\n    get: curryThis1(decInfo[3]),\n    set: curryThis2(decInfo[4])\n  } : 3 === kind ? {\n    get: decInfo[3]\n  } : 4 === kind ? {\n    set: decInfo[3]\n  } : {\n    value: decInfo[3]\n  } : 0 !== kind && (desc = Object.getOwnPropertyDescriptor(base, name)), 1 === kind ? value = {\n    get: desc.get,\n    set: desc.set\n  } : 2 === kind ? value = desc.value : 3 === kind ? value = desc.get : 4 === kind && (value = desc.set);\n  for (var inc = decoratorsHaveThis ? 2 : 1, i = decs.length - 1; i >= 0; i -= inc) {\n    var newInit;\n    if (void 0 !== (newValue = memberDec(decs[i], decoratorsHaveThis ? decs[i - 1] : void 0, name, desc, initializers, kind, isStatic, isPrivate, value, hasPrivateBrand))) assertValidReturnValue(kind, newValue), 0 === kind ? newInit = newValue : 1 === kind ? (newInit = newValue.init, get = newValue.get || value.get, set = newValue.set || value.set, value = {\n      get: get,\n      set: set\n    }) : value = newValue, void 0 !== newInit && (void 0 === init ? init = newInit : \"function\" == typeof init ? init = [init, newInit] : init.push(newInit));\n  }\n  if (0 === kind || 1 === kind) {\n    if (void 0 === init) init = function (instance, init) {\n      return init;\n    };else if (\"function\" != typeof init) {\n      var ownInitializers = init;\n      init = function (instance, init) {\n        for (var value = init, i = ownInitializers.length - 1; i >= 0; i--) value = ownInitializers[i].call(instance, value);\n        return value;\n      };\n    } else {\n      var originalInitializer = init;\n      init = function (instance, init) {\n        return originalInitializer.call(instance, init);\n      };\n    }\n    ret.push(init);\n  }\n  0 !== kind && (1 === kind ? (desc.get = value.get, desc.set = value.set) : 2 === kind ? desc.value = value : 3 === kind ? desc.get = value : 4 === kind && (desc.set = value), isPrivate ? 1 === kind ? (ret.push(function (instance, args) {\n    return value.get.call(instance, args);\n  }), ret.push(function (instance, args) {\n    return value.set.call(instance, args);\n  })) : 2 === kind ? ret.push(value) : ret.push(function (instance, args) {\n    return value.call(instance, args);\n  }) : Object.defineProperty(base, name, desc));\n}\nfunction applyMemberDecs(Class, decInfos, instanceBrand) {\n  for (var protoInitializers, staticInitializers, staticBrand, ret = [], existingProtoNonFields = new Map(), existingStaticNonFields = new Map(), i = 0; i < decInfos.length; i++) {\n    var decInfo = decInfos[i];\n    if (Array.isArray(decInfo)) {\n      var base,\n        initializers,\n        kind = decInfo[1],\n        name = decInfo[2],\n        isPrivate = decInfo.length > 3,\n        decoratorsHaveThis = 16 & kind,\n        isStatic = !!(8 & kind),\n        hasPrivateBrand = instanceBrand;\n      if (kind &= 7, isStatic ? (base = Class, 0 !== kind && (initializers = staticInitializers = staticInitializers || []), isPrivate && !staticBrand && (staticBrand = function (_) {\n        return _checkInRHS(_) === Class;\n      }), hasPrivateBrand = staticBrand) : (base = Class.prototype, 0 !== kind && (initializers = protoInitializers = protoInitializers || [])), 0 !== kind && !isPrivate) {\n        var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields,\n          existingKind = existingNonFields.get(name) || 0;\n        if (!0 === existingKind || 3 === existingKind && 4 !== kind || 4 === existingKind && 3 !== kind) throw new Error(\"Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: \" + name);\n        existingNonFields.set(name, !(!existingKind && kind > 2) || kind);\n      }\n      applyMemberDec(ret, base, decInfo, decoratorsHaveThis, name, kind, isStatic, isPrivate, initializers, hasPrivateBrand);\n    }\n  }\n  return pushInitializers(ret, protoInitializers), pushInitializers(ret, staticInitializers), ret;\n}\nfunction pushInitializers(ret, initializers) {\n  initializers && ret.push(function (instance) {\n    for (var i = 0; i < initializers.length; i++) initializers[i].call(instance);\n    return instance;\n  });\n}\nfunction applyClassDecs(targetClass, classDecs, decoratorsHaveThis) {\n  if (classDecs.length) {\n    for (var initializers = [], newClass = targetClass, name = targetClass.name, inc = decoratorsHaveThis ? 2 : 1, i = classDecs.length - 1; i >= 0; i -= inc) {\n      var decoratorFinishedRef = {\n        v: !1\n      };\n      try {\n        var nextNewClass = classDecs[i].call(decoratorsHaveThis ? classDecs[i - 1] : void 0, newClass, {\n          kind: \"class\",\n          name: name,\n          addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef)\n        });\n      } finally {\n        decoratorFinishedRef.v = !0;\n      }\n      void 0 !== nextNewClass && (assertValidReturnValue(5, nextNewClass), newClass = nextNewClass);\n    }\n    return [newClass, function () {\n      for (var i = 0; i < initializers.length; i++) initializers[i].call(newClass);\n    }];\n  }\n}\nfunction _applyDecs2305(targetClass, memberDecs, classDecs, classDecsHaveThis, instanceBrand) {\n  return {\n    e: applyMemberDecs(targetClass, memberDecs, instanceBrand),\n    get c() {\n      return applyClassDecs(targetClass, classDecs, classDecsHaveThis);\n    }\n  };\n}\nfunction _asyncGeneratorDelegate(inner) {\n  var iter = {},\n    waiting = !1;\n  function pump(key, value) {\n    return waiting = !0, value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    }), {\n      done: !1,\n      value: new _OverloadYield(value, 1)\n    };\n  }\n  return iter[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, iter.next = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"next\", value);\n  }, \"function\" == typeof inner.throw && (iter.throw = function (value) {\n    if (waiting) throw waiting = !1, value;\n    return pump(\"throw\", value);\n  }), \"function\" == typeof inner.return && (iter.return = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"return\", value);\n  }), iter;\n}\nfunction _asyncIterator(iterable) {\n  var method,\n    async,\n    sync,\n    retry = 2;\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function (s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function () {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    return: function (value) {\n      var ret = this.s.return;\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    throw: function (value) {\n      var thr = this.s.return;\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}\nfunction _awaitAsyncGenerator(value) {\n  return new _OverloadYield(value, 0);\n}\nfunction _checkInRHS(value) {\n  if (Object(value) !== value) throw TypeError(\"right-hand side of 'in' should be an object, got \" + (null !== value ? typeof value : \"null\"));\n  return value;\n}\nfunction _defineAccessor(type, obj, key, fn) {\n  var desc = {\n    configurable: !0,\n    enumerable: !0\n  };\n  return desc[type] = fn, Object.defineProperty(obj, key, desc);\n}\nfunction dispose_SuppressedError(suppressed, error) {\n  return \"undefined\" != typeof SuppressedError ? dispose_SuppressedError = SuppressedError : (dispose_SuppressedError = function (suppressed, error) {\n    this.suppressed = suppressed, this.error = error, this.stack = new Error().stack;\n  }, dispose_SuppressedError.prototype = Object.create(Error.prototype, {\n    constructor: {\n      value: dispose_SuppressedError,\n      writable: !0,\n      configurable: !0\n    }\n  })), new dispose_SuppressedError(suppressed, error);\n}\nfunction _dispose(stack, error, hasError) {\n  function next() {\n    if (0 !== stack.length) {\n      var r = stack.pop();\n      if (r.a) return Promise.resolve(r.d.call(r.v)).then(next, err);\n      try {\n        r.d.call(r.v);\n      } catch (e) {\n        return err(e);\n      }\n      return next();\n    }\n    if (hasError) throw error;\n  }\n  function err(e) {\n    return error = hasError ? new dispose_SuppressedError(e, error) : e, hasError = !0, next();\n  }\n  return next();\n}\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _iterableToArrayLimitLoose(arr, i) {\n  var _i = arr && (\"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n  if (null != _i) {\n    var _s,\n      _arr = [];\n    for (_i = _i.call(arr); arr.length < i && !(_s = _i.next()).done;) _arr.push(_s.value);\n    return _arr;\n  }\n}\nvar REACT_ELEMENT_TYPE;\nfunction _jsx(type, props, key, children) {\n  REACT_ELEMENT_TYPE || (REACT_ELEMENT_TYPE = \"function\" == typeof Symbol && Symbol.for && Symbol.for(\"react.element\") || 60103);\n  var defaultProps = type && type.defaultProps,\n    childrenLength = arguments.length - 3;\n  if (props || 0 === childrenLength || (props = {\n    children: void 0\n  }), 1 === childrenLength) props.children = children;else if (childrenLength > 1) {\n    for (var childArray = new Array(childrenLength), i = 0; i < childrenLength; i++) childArray[i] = arguments[i + 3];\n    props.children = childArray;\n  }\n  if (props && defaultProps) for (var propName in defaultProps) void 0 === props[propName] && (props[propName] = defaultProps[propName]);else props || (props = defaultProps || {});\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: void 0 === key ? null : \"\" + key,\n    ref: null,\n    props: props,\n    _owner: null\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  _regeneratorRuntime = function () {\n    return exports;\n  };\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function (obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function (method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function () {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function (exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function (record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function (finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    catch: function (tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _using(stack, value, isAwait) {\n  if (null == value) return value;\n  if (\"object\" != typeof value) throw new TypeError(\"using decarations can only be used with objects, null, or undefined.\");\n  if (isAwait) var dispose = value[Symbol.asyncDispose || Symbol.for(\"Symbol.asyncDispose\")];\n  if (null == dispose && (dispose = value[Symbol.dispose || Symbol.for(\"Symbol.dispose\")]), \"function\" != typeof dispose) throw new TypeError(\"Property [Symbol.dispose] is not a function.\");\n  return stack.push({\n    v: value,\n    d: dispose,\n    a: isAwait\n  }), value;\n}\nfunction _wrapRegExp() {\n  _wrapRegExp = function (re, groups) {\n    return new BabelRegExp(re, void 0, groups);\n  };\n  var _super = RegExp.prototype,\n    _groups = new WeakMap();\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);\n  }\n  function buildGroups(result, re) {\n    var g = _groups.get(re);\n    return Object.keys(g).reduce(function (groups, name) {\n      var i = g[name];\n      if (\"number\" == typeof i) groups[name] = result[i];else {\n        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;\n        groups[name] = result[i[k]];\n      }\n      return groups;\n    }, Object.create(null));\n  }\n  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n    if (result) {\n      result.groups = buildGroups(result, this);\n      var indices = result.indices;\n      indices && (indices.groups = buildGroups(indices, this));\n    }\n    return result;\n  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (\"string\" == typeof substitution) {\n      var groups = _groups.get(this);\n      return _super[Symbol.replace].call(this, str, substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n        var group = groups[name];\n        return \"$\" + (Array.isArray(group) ? group.join(\"$\") : group);\n      }));\n    }\n    if (\"function\" == typeof substitution) {\n      var _this = this;\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = arguments;\n        return \"object\" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);\n      });\n    }\n    return _super[Symbol.replace].call(this, str, substitution);\n  }, _wrapRegExp.apply(this, arguments);\n}\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n  return obj;\n}\nfunction _defaults(obj, defaults) {\n  var keys = Object.getOwnPropertyNames(defaults);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var value = Object.getOwnPropertyDescriptor(defaults, key);\n    if (value && value.configurable && obj[key] === undefined) {\n      Object.defineProperty(obj, key, value);\n    }\n  }\n  return obj;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? Object(arguments[i]) : {};\n    var ownKeys = Object.keys(source);\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys.push.apply(ownKeys, Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n  return target;\n}\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return !!right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _newArrowCheck(innerThis, boundThis) {\n  if (innerThis !== boundThis) {\n    throw new TypeError(\"Cannot instantiate an arrow function\");\n  }\n}\nfunction _objectDestructuringEmpty(obj) {\n  if (obj == null) throw new TypeError(\"Cannot destructure \" + obj);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n      result;\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n    return _possibleConstructorReturn(this, result);\n  };\n}\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\nfunction set(target, property, value, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.set) {\n    set = Reflect.set;\n  } else {\n    set = function set(target, property, value, receiver) {\n      var base = _superPropBase(target, property);\n      var desc;\n      if (base) {\n        desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.set) {\n          desc.set.call(receiver, value);\n          return true;\n        } else if (!desc.writable) {\n          return false;\n        }\n      }\n      desc = Object.getOwnPropertyDescriptor(receiver, property);\n      if (desc) {\n        if (!desc.writable) {\n          return false;\n        }\n        desc.value = value;\n        Object.defineProperty(receiver, property, desc);\n      } else {\n        _defineProperty(receiver, property, value);\n      }\n      return true;\n    };\n  }\n  return set(target, property, value, receiver);\n}\nfunction _set(target, property, value, receiver, isStrict) {\n  var s = set(target, property, value, receiver || target);\n  if (!s && isStrict) {\n    throw new TypeError('failed to set property');\n  }\n  return value;\n}\nfunction _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  strings.raw = raw;\n  return strings;\n}\nfunction _readOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n}\nfunction _writeOnlyError(name) {\n  throw new TypeError(\"\\\"\" + name + \"\\\" is write-only\");\n}\nfunction _classNameTDZError(name) {\n  throw new ReferenceError(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n}\nfunction _temporalUndefined() {}\nfunction _tdz(name) {\n  throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n}\nfunction _temporalRef(val, name) {\n  return val === _temporalUndefined ? _tdz(name) : val;\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _slicedToArrayLoose(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimitLoose(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _maybeArrayLike(next, arr, i) {\n  if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n    var len = arr.length;\n    return _arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n  }\n  return next(arr, i);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function () {};\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function () {\n      it = it.call(o);\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _skipFirstGeneratorNext(fn) {\n  return function () {\n    var it = fn.apply(this, arguments);\n    it.next();\n    return it;\n  };\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _initializerWarningHelper(descriptor, context) {\n  throw new Error('Decorating class property failed. Please ensure that ' + 'transform-class-properties is enabled and runs after the decorators transform.');\n}\nfunction _initializerDefineProperty(target, property, descriptor, context) {\n  if (!descriptor) return;\n  Object.defineProperty(target, property, {\n    enumerable: descriptor.enumerable,\n    configurable: descriptor.configurable,\n    writable: descriptor.writable,\n    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0\n  });\n}\nfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n  var desc = {};\n  Object.keys(descriptor).forEach(function (key) {\n    desc[key] = descriptor[key];\n  });\n  desc.enumerable = !!desc.enumerable;\n  desc.configurable = !!desc.configurable;\n  if ('value' in desc || desc.initializer) {\n    desc.writable = true;\n  }\n  desc = decorators.slice().reverse().reduce(function (desc, decorator) {\n    return decorator(target, property, desc) || desc;\n  }, desc);\n  if (context && desc.initializer !== void 0) {\n    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n    desc.initializer = undefined;\n  }\n  if (desc.initializer === void 0) {\n    Object.defineProperty(target, property, desc);\n    desc = null;\n  }\n  return desc;\n}\nvar id = 0;\nfunction _classPrivateFieldLooseKey(name) {\n  return \"__private_\" + id++ + \"_\" + name;\n}\nfunction _classPrivateFieldLooseBase(receiver, privateKey) {\n  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n    throw new TypeError(\"attempted to use private field on non-instance\");\n  }\n  return receiver;\n}\nfunction _classPrivateFieldGet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classPrivateFieldSet(receiver, privateMap, value) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classPrivateFieldDestructureSet(receiver, privateMap) {\n  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, \"set\");\n  return _classApplyDescriptorDestructureSet(receiver, descriptor);\n}\nfunction _classExtractFieldDescriptor(receiver, privateMap, action) {\n  if (!privateMap.has(receiver)) {\n    throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n  }\n  return privateMap.get(receiver);\n}\nfunction _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"get\");\n  return _classApplyDescriptorGet(receiver, descriptor);\n}\nfunction _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n  _classApplyDescriptorSet(receiver, descriptor, value);\n  return value;\n}\nfunction _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n  return method;\n}\nfunction _classStaticPrivateMethodSet() {\n  throw new TypeError(\"attempted to set read only static private field\");\n}\nfunction _classApplyDescriptorGet(receiver, descriptor) {\n  if (descriptor.get) {\n    return descriptor.get.call(receiver);\n  }\n  return descriptor.value;\n}\nfunction _classApplyDescriptorSet(receiver, descriptor, value) {\n  if (descriptor.set) {\n    descriptor.set.call(receiver, value);\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    descriptor.value = value;\n  }\n}\nfunction _classApplyDescriptorDestructureSet(receiver, descriptor) {\n  if (descriptor.set) {\n    if (!(\"__destrObj\" in descriptor)) {\n      descriptor.__destrObj = {\n        set value(v) {\n          descriptor.set.call(receiver, v);\n        }\n      };\n    }\n    return descriptor.__destrObj;\n  } else {\n    if (!descriptor.writable) {\n      throw new TypeError(\"attempted to set read only private field\");\n    }\n    return descriptor;\n  }\n}\nfunction _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {\n  _classCheckPrivateStaticAccess(receiver, classConstructor);\n  _classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n  return _classApplyDescriptorDestructureSet(receiver, descriptor);\n}\nfunction _classCheckPrivateStaticAccess(receiver, classConstructor) {\n  if (receiver !== classConstructor) {\n    throw new TypeError(\"Private static access of wrong provenance\");\n  }\n}\nfunction _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\n  if (descriptor === undefined) {\n    throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n  }\n}\nfunction _decorate(decorators, factory, superClass, mixins) {\n  var api = _getDecoratorsApi();\n  if (mixins) {\n    for (var i = 0; i < mixins.length; i++) {\n      api = mixins[i](api);\n    }\n  }\n  var r = factory(function initialize(O) {\n    api.initializeInstanceElements(O, decorated.elements);\n  }, superClass);\n  var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators);\n  api.initializeClassElements(r.F, decorated.elements);\n  return api.runClassFinishers(r.F, decorated.finishers);\n}\nfunction _getDecoratorsApi() {\n  _getDecoratorsApi = function () {\n    return api;\n  };\n  var api = {\n    elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n    initializeInstanceElements: function (O, elements) {\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element) {\n          if (element.kind === kind && element.placement === \"own\") {\n            this.defineClassElement(O, element);\n          }\n        }, this);\n      }, this);\n    },\n    initializeClassElements: function (F, elements) {\n      var proto = F.prototype;\n      [\"method\", \"field\"].forEach(function (kind) {\n        elements.forEach(function (element) {\n          var placement = element.placement;\n          if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) {\n            var receiver = placement === \"static\" ? F : proto;\n            this.defineClassElement(receiver, element);\n          }\n        }, this);\n      }, this);\n    },\n    defineClassElement: function (receiver, element) {\n      var descriptor = element.descriptor;\n      if (element.kind === \"field\") {\n        var initializer = element.initializer;\n        descriptor = {\n          enumerable: descriptor.enumerable,\n          writable: descriptor.writable,\n          configurable: descriptor.configurable,\n          value: initializer === void 0 ? void 0 : initializer.call(receiver)\n        };\n      }\n      Object.defineProperty(receiver, element.key, descriptor);\n    },\n    decorateClass: function (elements, decorators) {\n      var newElements = [];\n      var finishers = [];\n      var placements = {\n        static: [],\n        prototype: [],\n        own: []\n      };\n      elements.forEach(function (element) {\n        this.addElementPlacement(element, placements);\n      }, this);\n      elements.forEach(function (element) {\n        if (!_hasDecorators(element)) return newElements.push(element);\n        var elementFinishersExtras = this.decorateElement(element, placements);\n        newElements.push(elementFinishersExtras.element);\n        newElements.push.apply(newElements, elementFinishersExtras.extras);\n        finishers.push.apply(finishers, elementFinishersExtras.finishers);\n      }, this);\n      if (!decorators) {\n        return {\n          elements: newElements,\n          finishers: finishers\n        };\n      }\n      var result = this.decorateConstructor(newElements, decorators);\n      finishers.push.apply(finishers, result.finishers);\n      result.finishers = finishers;\n      return result;\n    },\n    addElementPlacement: function (element, placements, silent) {\n      var keys = placements[element.placement];\n      if (!silent && keys.indexOf(element.key) !== -1) {\n        throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n      }\n      keys.push(element.key);\n    },\n    decorateElement: function (element, placements) {\n      var extras = [];\n      var finishers = [];\n      for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) {\n        var keys = placements[element.placement];\n        keys.splice(keys.indexOf(element.key), 1);\n        var elementObject = this.fromElementDescriptor(element);\n        var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject);\n        element = elementFinisherExtras.element;\n        this.addElementPlacement(element, placements);\n        if (elementFinisherExtras.finisher) {\n          finishers.push(elementFinisherExtras.finisher);\n        }\n        var newExtras = elementFinisherExtras.extras;\n        if (newExtras) {\n          for (var j = 0; j < newExtras.length; j++) {\n            this.addElementPlacement(newExtras[j], placements);\n          }\n          extras.push.apply(extras, newExtras);\n        }\n      }\n      return {\n        element: element,\n        finishers: finishers,\n        extras: extras\n      };\n    },\n    decorateConstructor: function (elements, decorators) {\n      var finishers = [];\n      for (var i = decorators.length - 1; i >= 0; i--) {\n        var obj = this.fromClassDescriptor(elements);\n        var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj);\n        if (elementsAndFinisher.finisher !== undefined) {\n          finishers.push(elementsAndFinisher.finisher);\n        }\n        if (elementsAndFinisher.elements !== undefined) {\n          elements = elementsAndFinisher.elements;\n          for (var j = 0; j < elements.length - 1; j++) {\n            for (var k = j + 1; k < elements.length; k++) {\n              if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) {\n                throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\");\n              }\n            }\n          }\n        }\n      }\n      return {\n        elements: elements,\n        finishers: finishers\n      };\n    },\n    fromElementDescriptor: function (element) {\n      var obj = {\n        kind: element.kind,\n        key: element.key,\n        placement: element.placement,\n        descriptor: element.descriptor\n      };\n      var desc = {\n        value: \"Descriptor\",\n        configurable: true\n      };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n      if (element.kind === \"field\") obj.initializer = element.initializer;\n      return obj;\n    },\n    toElementDescriptors: function (elementObjects) {\n      if (elementObjects === undefined) return;\n      return _toArray(elementObjects).map(function (elementObject) {\n        var element = this.toElementDescriptor(elementObject);\n        this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n        this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n        return element;\n      }, this);\n    },\n    toElementDescriptor: function (elementObject) {\n      var kind = String(elementObject.kind);\n      if (kind !== \"method\" && kind !== \"field\") {\n        throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"');\n      }\n      var key = _toPropertyKey(elementObject.key);\n      var placement = String(elementObject.placement);\n      if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") {\n        throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"');\n      }\n      var descriptor = elementObject.descriptor;\n      this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n      var element = {\n        kind: kind,\n        key: key,\n        placement: placement,\n        descriptor: Object.assign({}, descriptor)\n      };\n      if (kind !== \"field\") {\n        this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n      } else {\n        this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\");\n        this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\");\n        this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\");\n        element.initializer = elementObject.initializer;\n      }\n      return element;\n    },\n    toElementFinisherExtras: function (elementObject) {\n      var element = this.toElementDescriptor(elementObject);\n      var finisher = _optionalCallableProperty(elementObject, \"finisher\");\n      var extras = this.toElementDescriptors(elementObject.extras);\n      return {\n        element: element,\n        finisher: finisher,\n        extras: extras\n      };\n    },\n    fromClassDescriptor: function (elements) {\n      var obj = {\n        kind: \"class\",\n        elements: elements.map(this.fromElementDescriptor, this)\n      };\n      var desc = {\n        value: \"Descriptor\",\n        configurable: true\n      };\n      Object.defineProperty(obj, Symbol.toStringTag, desc);\n      return obj;\n    },\n    toClassDescriptor: function (obj) {\n      var kind = String(obj.kind);\n      if (kind !== \"class\") {\n        throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"');\n      }\n      this.disallowProperty(obj, \"key\", \"A class descriptor\");\n      this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n      this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n      this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n      this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n      var finisher = _optionalCallableProperty(obj, \"finisher\");\n      var elements = this.toElementDescriptors(obj.elements);\n      return {\n        elements: elements,\n        finisher: finisher\n      };\n    },\n    runClassFinishers: function (constructor, finishers) {\n      for (var i = 0; i < finishers.length; i++) {\n        var newConstructor = (0, finishers[i])(constructor);\n        if (newConstructor !== undefined) {\n          if (typeof newConstructor !== \"function\") {\n            throw new TypeError(\"Finishers must return a constructor.\");\n          }\n          constructor = newConstructor;\n        }\n      }\n      return constructor;\n    },\n    disallowProperty: function (obj, name, objectType) {\n      if (obj[name] !== undefined) {\n        throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n      }\n    }\n  };\n  return api;\n}\nfunction _createElementDescriptor(def) {\n  var key = _toPropertyKey(def.key);\n  var descriptor;\n  if (def.kind === \"method\") {\n    descriptor = {\n      value: def.value,\n      writable: true,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"get\") {\n    descriptor = {\n      get: def.value,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"set\") {\n    descriptor = {\n      set: def.value,\n      configurable: true,\n      enumerable: false\n    };\n  } else if (def.kind === \"field\") {\n    descriptor = {\n      configurable: true,\n      writable: true,\n      enumerable: true\n    };\n  }\n  var element = {\n    kind: def.kind === \"field\" ? \"field\" : \"method\",\n    key: key,\n    placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\",\n    descriptor: descriptor\n  };\n  if (def.decorators) element.decorators = def.decorators;\n  if (def.kind === \"field\") element.initializer = def.value;\n  return element;\n}\nfunction _coalesceGetterSetter(element, other) {\n  if (element.descriptor.get !== undefined) {\n    other.descriptor.get = element.descriptor.get;\n  } else {\n    other.descriptor.set = element.descriptor.set;\n  }\n}\nfunction _coalesceClassElements(elements) {\n  var newElements = [];\n  var isSameElement = function (other) {\n    return other.kind === \"method\" && other.key === element.key && other.placement === element.placement;\n  };\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    var other;\n    if (element.kind === \"method\" && (other = newElements.find(isSameElement))) {\n      if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) {\n        if (_hasDecorators(element) || _hasDecorators(other)) {\n          throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\");\n        }\n        other.descriptor = element.descriptor;\n      } else {\n        if (_hasDecorators(element)) {\n          if (_hasDecorators(other)) {\n            throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\");\n          }\n          other.decorators = element.decorators;\n        }\n        _coalesceGetterSetter(element, other);\n      }\n    } else {\n      newElements.push(element);\n    }\n  }\n  return newElements;\n}\nfunction _hasDecorators(element) {\n  return element.decorators && element.decorators.length;\n}\nfunction _isDataDescriptor(desc) {\n  return desc !== undefined && !(desc.value === undefined && desc.writable === undefined);\n}\nfunction _optionalCallableProperty(obj, name) {\n  var value = obj[name];\n  if (value !== undefined && typeof value !== \"function\") {\n    throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n  }\n  return value;\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _classPrivateMethodSet() {\n  throw new TypeError(\"attempted to reassign private method\");\n}\nfunction _identity(x) {\n  return x;\n}","import { Color, Canvas, UITransform, instantiate, math, Toggle, TextureCube, _decorator, Component, Button, labelAssembler, game, director, Node, Scene, renderer, CameraComponent, Label, ForwardPipeline, RichText } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('internal.DebugViewRuntimeControl')\r\nexport class DebugViewRuntimeControl extends Component {\r\n    @property(Node)\r\n    compositeModeToggle: Node | null = null;\r\n    @property(Node)\r\n    singleModeToggle: Node | null = null;\r\n    @property(Node)\r\n    EnableAllCompositeModeButton: Node | null = null;\r\n\t_single: number = 0;\r\n\r\n    private strSingle: string[] = [\r\n        'No Single Debug',\r\n        'Vertex Color',\r\n        'Vertex Normal',\r\n        'Vertex Tangent',\r\n        'World Position',\r\n        'Vertex Mirror',\r\n        'Face Side',\r\n        'UV0',\r\n        'UV1',\r\n        'UV Lightmap',\r\n        'Project Depth',\r\n        'Linear Depth',\r\n\r\n        'Fragment Normal',\r\n        'Fragment Tangent',\r\n        'Fragment Binormal',\r\n        'Base Color',\r\n        'Diffuse Color',\r\n        'Specular Color',\r\n        'Transparency',\r\n        'Metallic',\r\n        'Roughness',\r\n        'Specular Intensity',\r\n        'IOR',\r\n\r\n        'Direct Diffuse',\r\n        'Direct Specular',\r\n        'Direct All',\r\n        'Env Diffuse',\r\n        'Env Specular',\r\n        'Env All',\r\n        'Emissive',\r\n        'Light Map',\r\n        'Shadow',\r\n        'AO',\r\n\r\n        'Fresnel',\r\n        'Direct Transmit Diffuse',\r\n        'Direct Transmit Specular',\r\n        'Env Transmit Diffuse',\r\n        'Env Transmit Specular',\r\n        'Transmit All',\r\n        'Direct Internal Specular',\r\n        'Env Internal Specular',\r\n        'Internal All',\r\n\r\n        'Fog',\r\n    ];\r\n    private strComposite: string[] = [\r\n        'Direct Diffuse',\r\n        'Direct Specular',\r\n        'Env Diffuse',\r\n        'Env Specular',\r\n        'Emissive',\r\n        'Light Map',\r\n        'Shadow',\r\n        'AO',\r\n\r\n        'Normal Map',\r\n        'Fog',\r\n\r\n        'Tone Mapping',\r\n        'Gamma Correction',\r\n\r\n        'Fresnel',\r\n        'Transmit Diffuse',\r\n        'Transmit Specular',\r\n        'Internal Specular',\r\n        'TT',\r\n    ];\r\n    private strMisc: string[] = [\r\n        'CSM Layer Coloration',\r\n        'Lighting With Albedo',\r\n    ];\r\n\r\n    private compositeModeToggleList: Node[] = [];\r\n    private singleModeToggleList: Node[] = [];\r\n    private miscModeToggleList: Node[] = [];\r\n    private textComponentList: RichText[] = [];\r\n    private labelComponentList: Label[] = [];\r\n    private textContentList: string[] = [];\r\n    private hideButtonLabel: Label;\r\n    start() {\r\n        // get canvas resolution\r\n        const canvas = this.node.parent.getComponent(Canvas);\r\n        if (!canvas) {\r\n            console.error('debug-view-runtime-control should be child of Canvas');\r\n            return;\r\n        }\r\n\r\n        const uiTransform = this.node.parent.getComponent(UITransform);\r\n        const halfScreenWidth = uiTransform.width * 0.5;\r\n        const halfScreenHeight = uiTransform.height * 0.5;\r\n\r\n        let x = -halfScreenWidth + halfScreenWidth * 0.1, y = halfScreenHeight - halfScreenHeight * 0.1;\r\n        const width = 200, height = 20;\r\n\r\n        // new nodes\r\n        const miscNode = this.node.getChildByName('MiscMode');\r\n        const buttonNode = instantiate(miscNode);\r\n        buttonNode.parent = this.node;\r\n        buttonNode.name = 'Buttons';\r\n        const titleNode = instantiate(miscNode);\r\n        titleNode.parent = this.node;\r\n        titleNode.name = 'Titles';\r\n\r\n        // title\r\n        for (let i = 0; i < 2; i++) {\r\n            const newLabel = instantiate(this.EnableAllCompositeModeButton.getChildByName('Label'));\r\n            newLabel.setPosition(x + (i > 0 ? 50 + width * 2 : 150), y, 0.0);\r\n            newLabel.setScale(0.75, 0.75, 0.75);\r\n            newLabel.parent = titleNode;\r\n            const labelComponent = newLabel.getComponent(Label);\r\n            labelComponent.string = i ? '----------Composite Mode----------' : '----------Single Mode----------';\r\n            labelComponent.color = Color.WHITE;\r\n            labelComponent.overflow = 0;\r\n            this.labelComponentList[this.labelComponentList.length] = labelComponent;\r\n        }\r\n\r\n        y -= height;\r\n        // single\r\n        let currentRow = 0;\r\n        for (let i = 0; i < this.strSingle.length; i++, currentRow++) {\r\n            if (i === this.strSingle.length >> 1) {\r\n                x += width;\r\n                currentRow = 0;\r\n            }\r\n            const newNode = i ? instantiate(this.singleModeToggle) : this.singleModeToggle;\r\n            newNode.setPosition(x, y - height * currentRow, 0.0);\r\n            newNode.setScale(0.5, 0.5, 0.5);\r\n            newNode.parent = this.singleModeToggle.parent;\r\n\r\n            const textComponent = newNode.getComponentInChildren(RichText);\r\n            textComponent.string = this.strSingle[i];\r\n            this.textComponentList[this.textComponentList.length] = textComponent;\r\n            this.textContentList[this.textContentList.length] = textComponent.string;\r\n\r\n            newNode.on(Toggle.EventType.TOGGLE, this.toggleSingleMode, this);\r\n\r\n            this.singleModeToggleList[i] = newNode;\r\n        }\r\n\r\n        x += width;\r\n        // buttons\r\n        this.EnableAllCompositeModeButton.setPosition(x + 15, y, 0.0);\r\n        this.EnableAllCompositeModeButton.setScale(0.5, 0.5, 0.5);\r\n        this.EnableAllCompositeModeButton.on(Button.EventType.CLICK, this.enableAllCompositeMode, this);\r\n        this.EnableAllCompositeModeButton.parent = buttonNode;\r\n        let labelComponent = this.EnableAllCompositeModeButton.getComponentInChildren(Label);\r\n        this.labelComponentList[this.labelComponentList.length] = labelComponent;\r\n\r\n        const changeColorButton = instantiate(this.EnableAllCompositeModeButton);\r\n        changeColorButton.setPosition(x + 90, y, 0.0);\r\n        changeColorButton.setScale(0.5, 0.5, 0.5);\r\n        changeColorButton.on(Button.EventType.CLICK, this.changeTextColor, this);\r\n        changeColorButton.parent = buttonNode;\r\n        labelComponent = changeColorButton.getComponentInChildren(Label);\r\n        labelComponent.string = 'TextColor';\r\n        this.labelComponentList[this.labelComponentList.length] = labelComponent;\r\n\r\n        const HideButton = instantiate(this.EnableAllCompositeModeButton);\r\n        HideButton.setPosition(x + 200, y, 0.0);\r\n        HideButton.setScale(0.5, 0.5, 0.5);\r\n        HideButton.on(Button.EventType.CLICK, this.hideUI, this);\r\n        HideButton.parent = this.node.parent;\r\n        labelComponent = HideButton.getComponentInChildren(Label);\r\n        labelComponent.string = 'Hide UI';\r\n        this.labelComponentList[this.labelComponentList.length] = labelComponent;\r\n        this.hideButtonLabel = labelComponent;\r\n\r\n        // misc\r\n        y -= 40;\r\n        for (let i = 0; i < this.strMisc.length; i++) {\r\n            const newNode = instantiate(this.compositeModeToggle);\r\n            newNode.setPosition(x, y - height * i, 0.0);\r\n            newNode.setScale(0.5, 0.5, 0.5);\r\n            newNode.parent = miscNode;\r\n\r\n            const textComponent = newNode.getComponentInChildren(RichText);\r\n            textComponent.string = this.strMisc[i];\r\n            this.textComponentList[this.textComponentList.length] = textComponent;\r\n            this.textContentList[this.textContentList.length] = textComponent.string;\r\n\r\n            const toggleComponent = newNode.getComponent(Toggle);\r\n            toggleComponent.isChecked = i ? true : false;\r\n            newNode.on(Toggle.EventType.TOGGLE, i ? this.toggleLightingWithAlbedo : this.toggleCSMColoration, this);\r\n            this.miscModeToggleList[i] = newNode;\r\n        }\r\n\r\n        // composite\r\n        y -= 150;\r\n        for (let i = 0; i < this.strComposite.length; i++) {\r\n            const newNode = i ? instantiate(this.compositeModeToggle) : this.compositeModeToggle;\r\n            newNode.setPosition(x, y - height * i, 0.0);\r\n            newNode.setScale(0.5, 0.5, 0.5);\r\n            newNode.parent = this.compositeModeToggle.parent;\r\n\r\n            const textComponent = newNode.getComponentInChildren(RichText);\r\n            textComponent.string = this.strComposite[i];\r\n            this.textComponentList[this.textComponentList.length] = textComponent;\r\n            this.textContentList[this.textContentList.length] = textComponent.string;\r\n\r\n            newNode.on(Toggle.EventType.TOGGLE, this.toggleCompositeMode, this);\r\n\r\n            this.compositeModeToggleList[i] = newNode;\r\n        }\r\n    }\r\n\r\n    isTextMatched(textUI, textDescription) : boolean {\r\n        let tempText = new String(textUI);\r\n        const findIndex = tempText.search('>');\r\n        if (findIndex === -1) {\r\n            return textUI === textDescription;\r\n        } else {\r\n            tempText = tempText.substr(findIndex + 1);\r\n            tempText = tempText.substr(0, tempText.search('<'));\r\n            return tempText === textDescription;\r\n        }\r\n    }\r\n    toggleSingleMode(toggle: Toggle) {\r\n        const debugView = director.root!.debugView;\r\n        const textComponent = toggle.getComponentInChildren(RichText);\r\n        for (let i = 0; i < this.strSingle.length; i++) {\r\n            if (this.isTextMatched(textComponent.string, this.strSingle[i])) {\r\n                debugView.singleMode = i;\r\n            }\r\n        }\r\n    }\r\n    toggleCompositeMode(toggle: Toggle) {\r\n        const debugView = director.root!.debugView;\r\n        const textComponent = toggle.getComponentInChildren(RichText);\r\n        for (let i = 0; i < this.strComposite.length; i++) {\r\n            if (this.isTextMatched(textComponent.string, this.strComposite[i])) {\r\n                debugView.enableCompositeMode(i, toggle.isChecked);\r\n            }\r\n        }\r\n    }\r\n    toggleLightingWithAlbedo(toggle: Toggle) {\r\n        const debugView = director.root!.debugView;\r\n        debugView.lightingWithAlbedo = toggle.isChecked;\r\n    }\r\n    toggleCSMColoration(toggle: Toggle) {\r\n        const debugView = director.root!.debugView;\r\n        debugView.csmLayerColoration = toggle.isChecked;\r\n    }\r\n    enableAllCompositeMode(button: Button) {\r\n        const debugView = director.root!.debugView;\r\n        debugView.enableAllCompositeMode(true);\r\n        for (let i = 0; i < this.compositeModeToggleList.length; i++) {\r\n            const toggleComponent = this.compositeModeToggleList[i].getComponent(Toggle);\r\n            toggleComponent.isChecked = true;\r\n        }\r\n\r\n        let toggleComponent = this.miscModeToggleList[0].getComponent(Toggle);\r\n        toggleComponent.isChecked = false;\r\n        debugView.csmLayerColoration = false;\r\n        toggleComponent = this.miscModeToggleList[1].getComponent(Toggle);\r\n        toggleComponent.isChecked = true;\r\n        debugView.lightingWithAlbedo = true;\r\n    }\r\n    hideUI(button: Button) {\r\n        const titleNode = this.node.getChildByName('Titles');\r\n        const activeValue = !titleNode.active;\r\n        this.singleModeToggleList[0].parent.active = activeValue;\r\n        this.miscModeToggleList[0].parent.active = activeValue;\r\n        this.compositeModeToggleList[0].parent.active = activeValue;\r\n        this.EnableAllCompositeModeButton.parent.active = activeValue;\r\n        titleNode.active = activeValue;\r\n        this.hideButtonLabel.string = activeValue ? 'Hide UI' : 'Show UI';\r\n    }\r\n\r\n    private _currentColorIndex = 0;\r\n    private strColor: string[] = [\r\n        '<color=#ffffff>',\r\n        '<color=#000000>',\r\n        '<color=#ff0000>',\r\n        '<color=#00ff00>',\r\n        '<color=#0000ff>',\r\n    ];\r\n    private color: Color[] = [\r\n        Color.WHITE,\r\n        Color.BLACK,\r\n        Color.RED,\r\n        Color.GREEN,\r\n        Color.BLUE,\r\n    ];\r\n    changeTextColor(button: Button) {\r\n        this._currentColorIndex++;\r\n        if (this._currentColorIndex >= this.strColor.length) {\r\n            this._currentColorIndex = 0;\r\n        }\r\n        for (let i = 0; i < this.textComponentList.length; i++) {\r\n            this.textComponentList[i].string = this.strColor[this._currentColorIndex] + this.textContentList[i] + '</color>';\r\n        }\r\n        for (let i = 0; i < this.labelComponentList.length; i++) {\r\n            this.labelComponentList[i].color = this.color[this._currentColorIndex];\r\n        }\r\n    }\r\n\r\n    onLoad() {\r\n    }\r\n    update(deltaTime: number) {\r\n    }\r\n}\r\n","\r\nimport { _decorator} from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\nexport enum MoveDirection {\r\n    MoveDown = 0,\r\n    MoveUp = 1,\r\n    MoveLeft = 2,\r\n    MoveRight = 3,\r\n    MoveXY = 4,\r\n}\r\n\r\nexport enum BulletTargetType {\r\n    ToAll = 0,\r\n    ToPlayer = 1,\r\n    ToEnemy = 2,\r\n} \r\n\r\nexport enum GameStatus {\r\n    Start,\r\n    Playing,\r\n    Pause,\r\n    Over\r\n}","import { GameLevel } from \"./gameLevel\";\r\nimport { GameStatus } from \"./common/Enums\";\r\n\r\nexport class GameContext {\r\n    //a single tone class to hold the game context\r\n    private static _instance:GameContext=null;\r\n    public static get instance(): GameContext{\r\n        if(GameContext._instance==null){\r\n            GameContext._instance=new GameContext();\r\n        }\r\n        return GameContext._instance;\r\n    }\r\n    private constructor(){}\r\n    //game status\r\n\r\n\r\n    public presetMessages: Array<string> = [\r\n        \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n        , \"\"\r\n    ];\r\n\r\n    // private gameManager: GameManager;\r\n\r\n    // constructor(gameManager: GameManager) {\r\n    //     this.gameManager = gameManager;\r\n    // }\r\n    public gameStatus: GameStatus = GameStatus.Start;\r\n    //score\r\n    public score: number = 0;\r\n    //game time\r\n    public gameTime: number = 0;\r\n    //player life\r\n    public life: number = 3;\r\n\r\n    private lastEnemyTime: number = 0;\r\n\r\n    private lastAwardTime: number = 0;\r\n\r\n    /***level settings**** */\r\n    public levelSetting: {\r\n        enemyInterval: number,\r\n        enemyShootThreshold: number,\r\n        enemyShootSpeed: number,\r\n        enemyShootInterval: number,\r\n        enemySpeed: number,\r\n        awardInterval: number,\r\n        levelUpScore: number,\r\n        levelName: string,\r\n        level: number,\r\n    }={\r\n        enemyInterval: 1,\r\n        enemyShootThreshold: 1,\r\n        enemyShootSpeed: 100,\r\n        enemyShootInterval: 1,\r\n        enemySpeed: 300,\r\n        awardInterval: 5,\r\n        levelUpScore: 100,\r\n        levelName: \"\",\r\n        level: 1,\r\n    };\r\n\r\n    public useGameLevel(level: GameLevel) {\r\n        this.levelSetting = {\r\n            enemyInterval: level.enemyInterval,\r\n            enemyShootThreshold: level.enemyShootThreshold,\r\n            enemyShootSpeed: level.enemyShootSpeed,\r\n            enemyShootInterval: level.enemyShootInterval,\r\n            enemySpeed: level.enemySpeed,\r\n            awardInterval: level.awardInterval,\r\n            levelUpScore: level.levelUpScore,\r\n            levelName: level.levelName,\r\n            level: level.level\r\n        };\r\n    }\r\n\r\n    //start game and reset all the context\r\n    public reset() {\r\n        this.gameStatus = GameStatus.Start;\r\n        this.score = 0;\r\n        this.gameTime = 0;\r\n        this.life = 3;\r\n        // this.enemyInterval=1;\r\n        // this.enemyShootThreshold=1;\r\n        // this.enemyShootSpeed=100;\r\n        // this.awardInterval=5;\r\n        this.lastEnemyTime = 0;\r\n        this.lastAwardTime = 0;\r\n    }\r\n\r\n    public shouldCreateEnemy(deltaTime: number): boolean {\r\n        this.lastEnemyTime += deltaTime;\r\n        if (this.lastEnemyTime >= this.levelSetting.enemyInterval) {\r\n            this.lastEnemyTime = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    public shouldCreateAward(deltaTime: number): boolean {\r\n        this.lastAwardTime += deltaTime;\r\n        if (this.lastAwardTime >= this.levelSetting.awardInterval) {\r\n            this.lastAwardTime = 0;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    public randomEnemyShoot(): boolean {\r\n        let rnd=Math.random();\r\n        //console.log(rnd, GameContext.instance.levelSetting.enemyShootThreshold);\r\n        return  rnd>= this.levelSetting.enemyShootThreshold;\r\n    }\r\n\r\n}\r\n","import { _decorator, Component, Node, UITransform, instantiate, director, Canvas, Sprite, SpriteFrame } from 'cc';\r\nimport { GameContext } from './gameContext';\r\nimport { GameStatus } from './common/Enums';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('bg')\r\nexport class bg extends Component {\r\n    start() {\r\n\r\n    }\r\n\r\n\r\n    adjustLayout() {\r\n        let contentSize = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).contentSize;\r\n        this.node.getComponent(UITransform).setContentSize(contentSize);\r\n        let bgImg = this.node.children[0];\r\n        bgImg.getComponent(UITransform).setContentSize(contentSize);\r\n    }\r\n\r\n    onLoad() {\r\n        this.adjustLayout();\r\n        //canvas size\r\n        let bgImg = this.node.children[0];\r\n        let node = instantiate(bgImg);\r\n        node.scale = bgImg.scale;\r\n        node.parent = this.node;\r\n        node.active = true;\r\n        //this.bg.addChild(node);\r\n        node.setPosition(bgImg.position.x, bgImg.position.y + bgImg.getComponent(UITransform).contentSize.height);\r\n        node.setSiblingIndex(bgImg.getSiblingIndex());\r\n    }\r\n\r\n    setBackGroundFrame(spriteFrame: SpriteFrame) {\r\n        if (spriteFrame != null) {\r\n            let bgImg = this.node.children[0];\r\n            bgImg.getComponent(Sprite).spriteFrame = spriteFrame;\r\n            if (this.node.children.length >= 2) {\r\n                let clonedBgImg = this.node.children[1];\r\n                clonedBgImg.getComponent(Sprite).spriteFrame = spriteFrame;\r\n\r\n            }\r\n        }\r\n    }\r\n    update(deltaTime: number) {\r\n\r\n        if (GameContext.instance.gameStatus != GameStatus.Pause) {\r\n\r\n            //console.log(contentSize); \r\n            //console.log(this.bg.children); \r\n            //this.bg1.setScale(screenWidth/contentWidth, screenHeight/contentHeight);\r\n            //this.bg2.setScale(screenWidth/contentWidth, screenHeight/contentHeight);\r\n            //this.bg1.getComponent(UITransform).setContentSize(screenWidth, screenHeight);\r\n            //this.bg2.getComponent(UITransform).setContentSize(screenWidth, screenHeight);\r\n            //console.log(\"screenWidth=\"+screenWidth+\",screenHeight=\"+screenHeight);\r\n            if (this.node.children.length >= 2) {\r\n                let bgImg = this.node.children[0];\r\n                let contentSize = bgImg.getComponent(UITransform).contentSize;\r\n                let clonedBgImg = this.node.children[1];\r\n\r\n                var bg1X = bgImg.position.x;\r\n                var bg1Y = bgImg.position.y;\r\n                var bg2X = clonedBgImg.position.x;\r\n                var bg2Y = clonedBgImg.position.y;\r\n                bg1Y -= 1;\r\n                bg2Y -= 1;\r\n                //IF bg1 is out of screen, then move it to the top of bg2\r\n                if (bg1Y <= -contentSize.height) {\r\n                    bg1Y = bg2Y + contentSize.height;\r\n                }\r\n                //IF bg2 is out of screen, then move it to the top of bg1\r\n                if (bg2Y <= -contentSize.height) {\r\n                    bg2Y = bg1Y + contentSize.height;\r\n                }\r\n                bgImg.setPosition(bg1X, bg1Y);\r\n                clonedBgImg.setPosition(bg2X, bg2Y);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { _decorator, Component, Node, Collider2D, Contact2DType } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('PhysicsObject')\r\nexport class PhysicsObject extends Component {\r\n    start() {\r\n\r\n        let collider = this.getComponent(Collider2D);\r\n        if (collider) {\r\n            collider.on(Contact2DType.BEGIN_CONTACT, this.onCollisionEnter, this);\r\n            collider.on(Contact2DType.END_CONTACT, this.onCollisionOut, this);\r\n        }\r\n\r\n    }\r\n    \r\n    protected onCollisionEnter(self: Collider2D, other: Collider2D) :void {\r\n    \r\n    }\r\n\r\n    protected onCollisionOut(self: Collider2D, other: Collider2D) :void {\r\n    \r\n    }\r\n\r\n    private _destoryCallback:Function=(sender:PhysicsObject)=>{};\r\n    //define a external callback function\r\n    /***\r\n     * when destroy, call this function(sender:PhysicsObject)\r\n     */\r\n    public get destoryCallback():Function{\r\n        return this._destoryCallback;\r\n    }\r\n    public set destoryCallback(value:Function){\r\n        this._destoryCallback=value;\r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Enum, Node, director, Canvas, UITransform, Vec3, v3 } from 'cc';\r\nimport { PhysicsObject } from './PhysicsObject';\r\nimport { MoveDirection } from './Enums';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('YMoveable')\r\nexport class YMoveable extends PhysicsObject {\r\n\r\n    //@property(Number)\r\n    public speed: number = 100;\r\n    //@property(Number)\r\n    @property({ type: Enum(MoveDirection) })\r\n    public direction: MoveDirection = MoveDirection.MoveUp;\r\n\r\n    public targetXY: Vec3= v3(0,0,0);\r\n    private fromPos: Vec3= v3(0,0,0);\r\n\r\n    start() {\r\n        super.start();\r\n        this.fromPos = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).convertToWorldSpaceAR(this.node.position);\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        /****\r\n         * direction, if=1 then move bullet up, else then move down, if bullet is out of screen, then destroy it\r\n         */\r\n        //if direction=1, then move bullet up\r\n\r\n        let screenWidth = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).contentSize.width;\r\n        let screenHeight = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).contentSize.height;\r\n\r\n        if (this.direction == MoveDirection.MoveUp) {\r\n            this.node.setPosition(this.node.position.x, this.node.position.y + this.speed * deltaTime);\r\n        } else if (this.direction == MoveDirection.MoveDown) {\r\n            this.node.setPosition(this.node.position.x, this.node.position.y - this.speed * deltaTime);\r\n        } else if (this.direction == MoveDirection.MoveXY) {\r\n            let deltaX = Math.abs(this.targetXY.x - this.fromPos.x);\r\n            let deltaY = Math.abs(this.targetXY.y - this.fromPos.y);\r\n            var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n\r\n            var x = this.node.position.x;\r\n            var y = this.node.position.y;\r\n            if (this.targetXY.y > this.fromPos.y) {\r\n                y += this.speed * (deltaY/distance) * deltaTime\r\n            }\r\n            else {\r\n                y -= this.speed * (deltaY/distance) * deltaTime\r\n            }\r\n            if (this.targetXY.x > this.fromPos.x) {\r\n                x += this.speed * (deltaX/distance) * deltaTime\r\n            }\r\n            else {\r\n                x -= this.speed * (deltaX/distance) * deltaTime\r\n            }\r\n            this.node.setPosition(x, y);\r\n        }\r\n\r\n        if (this.node.position.y <= -screenHeight / 2\r\n            || this.node.position.y >= screenHeight / 2\r\n            || this.node.position.x <= -screenWidth / 2\r\n            || this.node.position.x >= screenWidth / 2\r\n        ) {\r\n            this.node.destroy();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { _decorator, Component, Enum, tween, CCBoolean, Node, director, v3, Canvas, UITransform, Collider2D, Contact2DType, SpriteFrame, Sprite } from 'cc';\r\n\r\nimport { BulletTargetType, GameStatus } from './common/Enums';\r\nimport { YMoveable } from './common/YMoveable';\r\nimport { GameContext } from './gameContext';\r\n\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Bullet')\r\nexport class Bullet extends YMoveable {\r\n\r\n    public sender: Component = null;\r\n    public damage: number = 0;\r\n    public speed: number = 100;\r\n    @property(CCBoolean)\r\n    public hasAnimation: boolean = false;\r\n    @property({ type: Enum(BulletTargetType) })\r\n    public targetType: BulletTargetType = BulletTargetType.ToEnemy;\r\n\r\n    public useSkin(frame: SpriteFrame): void {\r\n        //change Sprite Frame\r\n        this.node.getComponent(Sprite).spriteFrame = frame;\r\n    }\r\n\r\n    start() {\r\n        super.start();\r\n        if(this.hasAnimation)\r\n        {\r\n            tween(this.node).repeatForever(\r\n                tween()\r\n                .by(0.3, {scale: v3(1, 1, 1)})\r\n                .by(0.3, {scale: v3(-1, -1, -1)})\r\n                ).start();\r\n        }\r\n    }\r\n\r\n    update(deltaTime: number): void {\r\n        if (GameContext.instance.gameStatus != GameStatus.Pause) {\r\n            super.update(deltaTime);\r\n        }\r\n    }\r\n    //\r\n    onCollisionEnter(self: Collider2D, other: Collider2D) {\r\n        this.node.destroy();\r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Event, Node, Button, EventHandler, director, EventTouch }  from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('button')\r\nexport class button extends Component {\r\n    start() {\r\n\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        \r\n    }\r\n\r\n    onLoad() {\r\n        console.log(\"button.onLoad\");\r\n        //bind onclick event\r\n        this.node.on(Node.EventType.TOUCH_END, this.onBtnClick, this);\r\n\r\n    }\r\n    \r\n    onBtnClick(e:EventTouch) {\r\n        director.loadScene(\"gameplay\",function(arg, scene){\r\n            console.log(\"loadScene callback\");\r\n            console.log(arg);\r\n            console.log(scene);\r\n            //director.runScene(scene);\r\n        });\r\n        console.log(\"click\");\r\n        console.log(e);\r\n    }\r\n}\r\n\r\n\r\n","import { _decorator, CCInteger, Component } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Explosion')\r\nexport class Explosion extends Component {\r\n    @property(CCInteger)\r\n    public removeDelay:number=0.5;\r\n    start() {\r\n\r\n    }\r\n    protected onLoad(): void {\r\n        this.scheduleOnce(()=>{\r\n            this.node.destroy();\r\n        }, this.removeDelay);\r\n    }\r\n    update(deltaTime: number) {\r\n        \r\n    }\r\n}\r\n\r\n","import { _decorator, Component, Vec3, CCInteger, Node, director, Canvas, instantiate, AudioClip, AudioSourceComponent, ParticleSystem2D, ParticleSystemComponent, UITransform, Collider2D, Contact2DType, IPhysics2DContact, PhysicsSystem2D, Prefab } from 'cc';\r\nimport { YMoveable } from \"./common/YMoveable\";\r\nimport { Bullet } from \"./bullet\";\r\nimport { Explosion } from \"./common/explosion\";\r\nimport { BulletTargetType, MoveDirection, GameStatus } from './common/Enums';\r\nimport { GameContext } from './gameContext';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Enemy')\r\nexport class Enemy extends YMoveable {\r\n\r\n    public bulletInterval: number = 1;\r\n    @property(CCInteger)\r\n    public bulletSpeed: number = 50;\r\n    @property(CCInteger)\r\n    public bulletDamage: number = 10;\r\n    private lastShootTime: number = 0;\r\n\r\n    @property(Prefab)\r\n    private explosionPrefab: Prefab = null;\r\n    @property(Prefab)\r\n    private bulletPrefab: Prefab = null;\r\n\r\n    public target: Component;\r\n\r\n    constructor() {\r\n        super();\r\n        this.direction = MoveDirection.MoveDown;\r\n    }\r\n    start() {\r\n        super.start();\r\n        this.lastShootTime = this.bulletInterval;\r\n    }\r\n\r\n    update(deltaTime: number): void {\r\n        if (GameContext.instance.gameStatus != GameStatus.Pause) {\r\n            super.update(deltaTime);\r\n            this.lastShootTime += deltaTime;\r\n            if (this.lastShootTime >= this.bulletInterval) {\r\n                if (GameContext.instance.randomEnemyShoot()) {\r\n                    this.shoot();\r\n                }\r\n                this.lastShootTime = 0;\r\n            }\r\n        }\r\n    }\r\n    //\r\n    onCollisionEnter(self: Collider2D, other: Collider2D) {\r\n        //play fire sound\r\n        if (this.node.active) {\r\n            this.node.active = false;\r\n            if (this.explosionPrefab) {\r\n                let explosionNode = instantiate(this.explosionPrefab);\r\n                explosionNode.setPosition(this.node.position);\r\n                explosionNode.parent = this.node.parent;\r\n                explosionNode.getComponent(UITransform).setContentSize(this.node.getComponent(UITransform).contentSize);\r\n                explosionNode.getComponent(Explosion).removeDelay = 0.2;\r\n                explosionNode.active = true;\r\n            }\r\n            if (this.destoryCallback != null)\r\n                this.destoryCallback(this);\r\n            this.node.destroy();\r\n        }\r\n    }\r\n\r\n    //shoot bullet to attack player\r\n    shoot() {\r\n        //create bullet\r\n        if (this.target != null && this.target.node != null) {\r\n            let bulletNode = instantiate(this.bulletPrefab);\r\n            bulletNode.parent = this.node.parent;\r\n            bulletNode.setPosition(this.node.position);\r\n            var bulletObj = bulletNode.getComponent(Bullet);\r\n            bulletObj.sender = this;\r\n            bulletObj.damage = this.bulletDamage;\r\n            bulletObj.speed = this.bulletSpeed;\r\n            bulletObj.direction = MoveDirection.MoveXY;\r\n            bulletObj.targetType = BulletTargetType.ToPlayer;\r\n            bulletObj.targetXY = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).convertToWorldSpaceAR(this.target.node.position);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { _decorator, AudioClip, SpriteFrame, Component, Node, CCString, CCInteger, CCFloat } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('GameLevel')\r\nexport class GameLevel extends Component {\r\n\r\n    @property(CCInteger)\r\n    public level:number=1;\r\n    @property(CCFloat)\r\n    public enemyInterval: number = 1;\r\n    @property(CCFloat)\r\n    public enemyShootThreshold: number = 1;\r\n    @property(CCInteger)\r\n    public enemyShootSpeed: number = 100;\r\n    @property(CCInteger)\r\n    public enemySpeed: number = 300;\r\n    @property(CCFloat)\r\n    public enemyShootInterval: number = 1;\r\n    @property(CCFloat)\r\n    public awardInterval: number = 5;\r\n    @property(CCInteger)\r\n    public levelUpScore: number = 100;\r\n    @property(CCString)\r\n    public levelName:string=\"\";\r\n\r\n\r\n    @property(SpriteFrame)\r\n    public gameBgSpriteFrame: SpriteFrame = null;\r\n\r\n    @property(AudioClip)\r\n    public gameBgm:AudioClip=null;\r\n\r\n}\r\n\r\n","\r\nimport { Canvas } from 'cc';\r\nimport { _decorator, Component, Node, Button, Label, EventTouch, director, instantiate, Prefab, resources } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Dialog')\r\nexport class Dialog extends Component {\r\n\r\n    public static show(title: string, message: string, buttons: Array<{ label: string, action: Function }>, autoDismiss: boolean = true, pauseGame: boolean = false): Promise<Dialog> {\r\n        //dynamic load prefab from resource\r\n        /*****\r\n        let prefab = resources.get<Prefab>(\"prefabs/ui/dialog\");\r\n        let dialog = instantiate(prefab);\r\n        dialog.getComponent(Dialog).title = title;\r\n        dialog.getComponent(Dialog).message = message;\r\n        dialog.getComponent(Dialog).buttons = buttons;\r\n        dialog.setPosition(0, 0);\r\n        dialog.parent = director.getScene().getComponentInChildren(Canvas).node;\r\n        dialog.active = true;\r\n        */\r\n        var promise = new Promise<Dialog>((resolve, reject) => {\r\n            resources.load(\"prefabs/ui/dialog\", Prefab, (err, prefab) => {\r\n                console.log(err);\r\n                const dialog = instantiate(prefab);\r\n                dialog.getComponent(Dialog).title = title;\r\n                dialog.getComponent(Dialog).message = message;\r\n                dialog.getComponent(Dialog).buttons = buttons;\r\n                dialog.getComponent(Dialog).autoDismiss = autoDismiss;\r\n                dialog.getComponent(Dialog).pauseGame = pauseGame;\r\n                dialog.setPosition(0, 0);\r\n                dialog.parent = director.getScene().getComponentInChildren(Canvas).node;\r\n                dialog.active = true;\r\n                resolve(dialog.getComponent(Dialog));\r\n            });\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    @property(Label)\r\n    private titleNode: Label = null;\r\n    @property(Label)\r\n    private messageNode: Label = null;\r\n    @property(Button)\r\n    private leftBtn: Button = null;\r\n    @property(Button)\r\n    private rightBtn: Button = null;\r\n\r\n    /**\r\n     * auto dismiss after button click\r\n     */\r\n    public autoDismiss: boolean = true;\r\n    public pauseGame: boolean = false;\r\n\r\n    public set title(val: string) {\r\n        this.titleNode.string = val;\r\n    }\r\n\r\n    public set message(val: string) {\r\n        this.messageNode.string = val;\r\n    }\r\n\r\n\r\n    start() {\r\n    }\r\n\r\n    public dismiss() {\r\n        this.node.destroy();\r\n    }\r\n\r\n    /**\r\n     * buttons: [{label:string, action:Function}]\r\n     * label: button label\r\n     * action: button click callback, function(e:EventTouch, dialog:dialog)\r\n     */\r\n    public buttons: Array<{ label: string, action: Function }> = [];\r\n\r\n    protected onLoad(): void {\r\n        this.leftBtn.node.active = false;\r\n        this.rightBtn.node.active = false;\r\n        if (this.buttons.length == 1) {\r\n            this.leftBtn.node.active = true;\r\n            this.leftBtn.getComponentInChildren(Label).string = this.buttons[0].label;\r\n            this.leftBtn.node.on(Node.EventType.TOUCH_END, this.onLeftButtonClick, this);\r\n            this.leftBtn.node.setPosition(0, this.leftBtn.node.position.y);\r\n        } else if (this.buttons.length == 2) {\r\n            this.leftBtn.node.active = true;\r\n            this.leftBtn.getComponentInChildren(Label).string = this.buttons[0].label;\r\n            this.leftBtn.node.on(Node.EventType.TOUCH_END, this.onLeftButtonClick, this);\r\n            this.leftBtn.node.setPosition(-75, this.leftBtn.node.position.y);\r\n\r\n            this.rightBtn.node.active = true;\r\n            this.rightBtn.getComponentInChildren(Label).string = this.buttons[1].label;\r\n            this.rightBtn.node.on(Node.EventType.TOUCH_END, this.onRightButtonClick, this);\r\n            this.rightBtn.node.setPosition(75, this.leftBtn.node.position.y);\r\n        }\r\n    }\r\n\r\n    onLeftButtonClick(e: EventTouch) {\r\n        if (this.buttons[0].action != null)\r\n            this.buttons[0].action(e, this);\r\n        if (this.autoDismiss) {\r\n            this.dismiss();\r\n        }\r\n    }\r\n\r\n    onRightButtonClick(e: EventTouch) {\r\n        if (this.buttons[1].action != null)\r\n            this.buttons[1].action(e, this);\r\n        if (this.autoDismiss) {\r\n            this.dismiss();\r\n        }\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n\r\n    }\r\n}\r\n\r\n","import { Label, tween, CCInteger, resources, Prefab, instantiate, director, Canvas, _decorator, Component, Node, v3 } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('Toast')\r\nexport class Toast extends Component {\r\n\r\n\r\n    public static show(message: string, duration: number = 0, action: Function): Promise<Toast> {\r\n        //dynamic load prefab from resource\r\n        /*****\r\n        let prefab = resources.get<Prefab>(\"prefabs/ui/dialog\");\r\n        let dialog = instantiate(prefab);\r\n        dialog.getComponent(Dialog).title = title;\r\n        dialog.getComponent(Dialog).message = message;\r\n        dialog.getComponent(Dialog).buttons = buttons;\r\n        dialog.setPosition(0, 0);\r\n        dialog.parent = director.getScene().getComponentInChildren(Canvas).node;\r\n        dialog.active = true;\r\n        */\r\n        var promise = new Promise<Toast>((resolve, reject) => {\r\n            resources.load(\"prefabs/ui/toast\", Prefab, (err, prefab) => {\r\n\r\n                const dialog = instantiate(prefab);\r\n                dialog.getComponent(Toast).duration = duration;\r\n                dialog.getComponent(Toast).callback = action;\r\n                dialog.getComponent(Toast).message = message;\r\n                dialog.setPosition(0, 0);\r\n                dialog.parent = director.getScene().getComponentInChildren(Canvas).node;\r\n                dialog.active = true;\r\n                resolve(dialog.getComponent(Toast));\r\n            });\r\n        });\r\n        return promise;\r\n    }\r\n\r\n    @property(CCInteger)\r\n    public duration: number = 0;\r\n\r\n    public message: string = \"\";\r\n\r\n    public callback: Function;\r\n\r\n    private messageLines: Array<string> = [];\r\n    private actualMessageLength: number = 0;\r\n\r\n    private playAnimation(lineIndex: number) {\r\n        if (lineIndex < this.messageLines.length) {\r\n            let str = this.messageLines[lineIndex];\r\n            this.node.getComponent(Label).string = str;\r\n            //set scale to 0.1\r\n            this.node.setScale(0, 0);\r\n            let duration=this.duration * str.length / this.actualMessageLength;\r\n            tween(this.node).sequence(\r\n                tween().to(duration/3, { scale: v3(1, 1, 1) }, {easing:\"elasticOut\"}),\r\n                tween().delay(duration/3),\r\n                tween().to(duration/3, { scale: v3(0, 0, 0) }, {easing:\"elasticIn\"})\r\n            ).call(() => {\r\n                this.playAnimation(lineIndex + 1);\r\n            }).start();\r\n        }\r\n        else {\r\n            if (this.callback != null) {\r\n                this.callback();\r\n            }\r\n            this.node.destroy();\r\n        }\r\n    }\r\n    \r\n    start() {\r\n        //split message into lines\r\n        if (this.duration > 0) {\r\n\r\n            let lines = this.message.split(\"\\n\");\r\n            lines.forEach(l => {\r\n                if (l != null && l.trim().length>0) {\r\n                    this.actualMessageLength = this.actualMessageLength + l.length;\r\n                    this.messageLines.push(l);\r\n                }\r\n            });\r\n\r\n            this.node.getComponent(Label).string = \"\";\r\n            this.playAnimation(0);\r\n        } else {\r\n\r\n            this.node.getComponent(Label).string = this.message;\r\n        }\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n\r\n    }\r\n}\r\n\r\n","\r\nimport { _decorator, CCInteger, Component, Node, SpriteFrame, Collider2D, AudioSourceComponent } from 'cc';\r\nimport { YMoveable } from './common/YMoveable';\r\nimport { GameContext } from './gameContext';\r\nimport { GameStatus } from \"./common/Enums\";\r\nimport { CCFloat } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n/*****\r\n * Weapon class to enhance the player's ability, upgrade the player's weapon, etc.\r\n *  */ \r\n@ccclass('Weapon')\r\nexport class Weapon extends YMoveable {\r\n\r\n    @property(SpriteFrame)\r\n    public playerSpriteFrame: SpriteFrame = null;\r\n\r\n    @property(CCInteger)\r\n    public bulletSpeed: number = 0;\r\n\r\n    @property(CCFloat)\r\n    public bulletInterval: number = 0;\r\n    \r\n    @property(CCInteger)\r\n    public bulletDamage: number = 0;\r\n\r\n    @property(CCInteger)\r\n    public numberOfBullets: number = 0;\r\n\r\n    @property(SpriteFrame)\r\n    public bulletSpriteFrame: SpriteFrame = null;\r\n\r\n    @property(CCInteger)\r\n    public duration: number = 0;\r\n\r\n    start() {\r\n        super.start();\r\n    }\r\n    \r\n    onCollisionEnter(self: Collider2D, other: Collider2D){\r\n        //play upgrade sound\r\n        this.node.removeFromParent();\r\n        var sound=this.node.getComponent(AudioSourceComponent);\r\n        if(sound!=null){\r\n            sound.play();\r\n            this.scheduleOnce(()=>{\r\n                this.node.destroy();\r\n            }, 0.5);\r\n        }else{\r\n            this.node.destroy();\r\n        }\r\n    }\r\n    \r\n    update(deltaTime: number): void {\r\n        if(GameContext.instance.gameStatus != GameStatus.Pause){\r\n            super.update(deltaTime);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n","import { _decorator, AudioSource, ProgressBar, sys, SpriteFrame, AudioClip, Node, EventTouch, instantiate, director, AudioSourceComponent, UITransform, v3, Prefab, Canvas, Collider2D, Contact2DType, Sprite } from 'cc';\r\nconst { ccclass, property } = _decorator;\r\nimport { Bullet } from \"./bullet\";\r\nimport { PhysicsObject } from \"./common/PhysicsObject\";\r\nimport { Explosion } from \"./common/explosion\";\r\nimport { Enemy } from './enemy';\r\nimport { Weapon } from './weapon';\r\nimport { BulletTargetType, MoveDirection, GameStatus } from './common/Enums';\r\nimport { GameContext } from './gameContext';\r\n\r\n@ccclass('Player')\r\nexport class Player extends PhysicsObject {\r\n\r\n    private lastShootTime: number = 0;\r\n\r\n    private bulletSetting: {\r\n        playerSpriteFrame: SpriteFrame,\r\n        bulletSpeed: number,\r\n        bulletInterval: number,\r\n        bulletDamage: number,\r\n        numberOfBullets: number,\r\n        bulletSpriteFrame: SpriteFrame,\r\n        duration: number;\r\n    };\r\n\r\n    @property(Prefab)\r\n    private defaultWeapon: Prefab = null;\r\n    @property(Prefab)\r\n    private bulletPrefab: Prefab = null;\r\n    @property(AudioClip)\r\n    private fireSound: AudioClip = null;\r\n    @property(AudioClip)\r\n    private pickupSound: AudioClip = null;\r\n    @property(Prefab)\r\n    private explosionPrefab: Prefab = null;\r\n    private explosionNode: Node = null;\r\n\r\n    @property(ProgressBar)\r\n    private progressBar: ProgressBar = null;\r\n\r\n    start() {\r\n        super.start();\r\n        this.lastShootTime = this.bulletSetting.bulletInterval;\r\n    }\r\n\r\n    private useWeapon(weapon: Weapon) {\r\n        //assign bullet setting\r\n        this.bulletSetting = {\r\n            playerSpriteFrame: weapon.playerSpriteFrame,\r\n            bulletSpeed: weapon.bulletSpeed,\r\n            bulletInterval: weapon.bulletInterval,\r\n            bulletDamage: weapon.bulletDamage,\r\n            numberOfBullets: weapon.numberOfBullets,\r\n            bulletSpriteFrame: weapon.bulletSpriteFrame,\r\n            duration: weapon.duration\r\n        };\r\n        //change player skin\r\n        if (weapon.playerSpriteFrame != null) {\r\n            this.node.getComponent(Sprite).spriteFrame = this.bulletSetting.playerSpriteFrame;\r\n        }\r\n        if (weapon.duration > 0) {\r\n            this.progressBar.progress = 1;\r\n            //set the position of progress bar to the bottom of player\r\n            this.progressBar.node.active = true;\r\n        } else {\r\n            this.progressBar.node.active = false;\r\n        }\r\n    }\r\n\r\n    onCollisionEnter(self: Collider2D, other: Collider2D) {\r\n\r\n        if (this.node.active) {\r\n\r\n            //if other is enemy, then game over\r\n            if (other.node.getComponent(Enemy) != null || other.node.getComponent(Bullet)?.targetType == BulletTargetType.ToPlayer) {\r\n                this.node.active = false;\r\n                GameContext.instance.gameStatus = GameStatus.Over;\r\n                if (this.explosionPrefab) {\r\n                    let explosionNode = instantiate(this.explosionPrefab);\r\n                    explosionNode.setPosition(this.node.position);\r\n                    explosionNode.parent = this.node.parent;\r\n                    explosionNode.getComponent(UITransform).setContentSize(this.node.getComponent(UITransform).contentSize);\r\n                    explosionNode.getComponent(Explosion).removeDelay = 0.2;\r\n                    explosionNode.active = true;\r\n                }\r\n                this.node.removeFromParent();\r\n                this.scheduleOnce(() => {\r\n                    if (this.destoryCallback != null)\r\n                        this.destoryCallback(this);\r\n                    this.node.destroy();\r\n                }, 0.5);\r\n            }\r\n            //else if award, then upgrade player\r\n            else if (other.node.getComponent(Weapon) != null) {\r\n                //upgrade player\r\n                let audioSource = new Node().addComponent(AudioSource);\r\n                audioSource.clip = this.pickupSound;\r\n                audioSource.play();\r\n                this.useWeapon(other.node.getComponent(Weapon));\r\n            }\r\n        }\r\n    }\r\n\r\n    onLoad() {\r\n        if (this.defaultWeapon != null) {\r\n            this.useWeapon(instantiate(this.defaultWeapon).getComponent(Weapon));\r\n        }\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        //if game is pause, then return\r\n        if (GameContext.instance.gameStatus == GameStatus.Playing) {\r\n            this.lastShootTime += deltaTime;\r\n            if (this.lastShootTime >= this.bulletSetting.bulletInterval) {\r\n                this.shoot();\r\n                this.lastShootTime = 0;\r\n            }\r\n            //update progress bar\r\n            if (this.progressBar.node.active) {\r\n                this.progressBar.progress -= deltaTime / this.bulletSetting.duration;\r\n                if (this.progressBar.progress <= 0) {\r\n                    this.progressBar.node.active = false;\r\n                    this.useWeapon(instantiate(this.defaultWeapon).getComponent(Weapon));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //shoot bullet\r\n    shoot() {\r\n        //generate multiple columns of bullets according to numberOfBullets\r\n        let playerSize = this.node.getComponent(UITransform).contentSize;\r\n        let bulletRangeWidth = playerSize.width;\r\n        if (this.bulletSetting.numberOfBullets > 4) {\r\n            bulletRangeWidth = playerSize.width * Math.min(this.bulletSetting.numberOfBullets / 4, 1.5);\r\n        }\r\n\r\n        for (let i = 1; i <= this.bulletSetting.numberOfBullets; i++) {\r\n            //get bullet prefab\r\n            //create bullet\r\n            let bullet = instantiate(this.bulletPrefab);\r\n            //convert bullet to Buttle\r\n            let bulletComponent = bullet.getComponent(Bullet);\r\n            //set bullet direction\r\n            bulletComponent.direction = MoveDirection.MoveUp;\r\n            //set bullet speed\r\n            bulletComponent.speed = this.bulletSetting.bulletSpeed;\r\n            bulletComponent.sender = this;\r\n            bulletComponent.damage = this.bulletSetting.bulletDamage;\r\n            if (this.bulletSetting.bulletSpriteFrame != null) {\r\n                //set bullet spriteFrame\r\n                bullet.getComponent(Sprite).spriteFrame = this.bulletSetting.bulletSpriteFrame;\r\n            }\r\n            let bulletX = this.node.position.x + bulletRangeWidth * i / (this.bulletSetting.numberOfBullets + 1) - bulletRangeWidth / 2;\r\n            //set bullet position \r\n            bullet.setPosition(bulletX, this.node.position.y + this.node.getComponent(UITransform).contentSize.height / 2);\r\n            //set bullet parent\r\n            bullet.parent = director.getScene().getComponentInChildren(Canvas).node;\r\n            //set bullet active\r\n            bullet.active = true;\r\n        }\r\n        //play fire sound\r\n        let audioSource = new Node().addComponent(AudioSource);\r\n        audioSource.clip = this.fireSound;\r\n        audioSource.play();\r\n    }\r\n}\r\n\r\n","import { _decorator, clamp, Tween, CCInteger, sys, CCBoolean, AudioClip, AudioSource, tween, Component, Node, EventTouch, Label, Sprite, UITransform, instantiate, director, Prefab, Canvas, Button, v3, PhysicsSystem2D, EPhysics2DDrawFlags } from 'cc';\r\nimport { Enemy } from './enemy';\r\nimport { YMoveable } from './common/YMoveable';\r\nimport { MoveDirection, GameStatus } from './common/Enums';\r\nimport { GameContext } from './gameContext';\r\nimport { Dialog } from './ui/dialog';\r\nimport { Toast } from './ui/toast';\r\nimport { GameLevel } from './gameLevel';\r\nimport { bg } from './bg';\r\nimport { Player } from './player';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('GameManager')\r\nexport class GameManager extends Component {\r\n    private static _instance: GameManager = null;\r\n    public static get instance(): GameManager {\r\n        return GameManager._instance;\r\n    }\r\n\r\n    @property(CCInteger)\r\n    private beginGameLevelIndex: number = 0;\r\n    @property(Prefab)\r\n    private gameLevels: Array<Prefab> = [];\r\n    private currentLevelIndex: number = 0;\r\n    @property(Prefab)\r\n    private weaponTypes: Array<Prefab> = [];\r\n    @property(Sprite)\r\n    private player: Sprite = null;\r\n    @property(Node)\r\n    private bg: Node = null;\r\n    @property(Prefab)\r\n    private enemyPrefab: Prefab = null;\r\n    @property(CCBoolean)\r\n    private isDebug: boolean = false;\r\n    @property(Button)\r\n    private btnBack: Button = null;\r\n    @property(Node)\r\n    private lblScore: Node = null;\r\n    @property(AudioClip)\r\n    private readyGoSound: AudioClip = null;\r\n\r\n    private context: GameContext = null;\r\n\r\n    constructor() {\r\n        super();\r\n        GameManager._instance = this;\r\n        this.context = GameContext.instance;\r\n    }\r\n\r\n    private beginingAnimation: Tween<Node> = null;\r\n    private beginingAnimationIsRunning: boolean = false;\r\n    adjustLayout() {\r\n        let contentSize = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).contentSize;\r\n        this.btnBack.node.setPosition(-(contentSize.width * 0.9 - this.btnBack.getComponent(UITransform).contentSize.width) / 2, (contentSize.height * 0.9 - this.btnBack.getComponent(UITransform).contentSize.height) / 2);\r\n        this.lblScore.setPosition(0, (contentSize.height * 0.9 - this.lblScore.getComponent(UITransform).contentSize.height) / 2);\r\n\r\n\r\n        let playerSize = this.player.node.getComponent(UITransform).contentSize;\r\n        this.player.node.setPosition(0, -contentSize.height / 2 - playerSize.height / 2);\r\n        //set start scale to 2\r\n        this.player.node.setScale(3, 3);\r\n        //target position on screen center middle\r\n        this.beginingAnimationIsRunning = true;\r\n        this.beginingAnimation = tween(this.player.node)\r\n            .to(3, {\r\n                position: v3(0, - playerSize.height / 2, 0)\r\n            }, { easing: 'expoOut' })\r\n            .call(() => {\r\n                this.beginingAnimationIsRunning = false;\r\n            }).start();\r\n\r\n        tween(this.player.node)\r\n            .to(3, {\r\n                scale: v3(1, 1, 1)\r\n            }, { easing: 'expoOut' }).start();\r\n\r\n        Toast.show(\"Ready\\nGo!\", 3, () => {\r\n            //bind onclick event\r\n            this.btnBack.node.on(Node.EventType.TOUCH_END, this.onBackBtnClick, this);\r\n            this.context.gameStatus = GameStatus.Playing;\r\n        });\r\n\r\n        this.scheduleOnce(() => {\r\n            // \r\n            //  AudioSource \r\n            const audioSource = new Node().addComponent(AudioSource);\r\n\r\n            //  AudioSource \r\n            audioSource.clip = this.readyGoSound;\r\n            audioSource.play();\r\n            //audioNode.active=true;\r\n        }, 0.5);\r\n    }\r\n\r\n    scoreAdd(score: number = 1) {\r\n        this.context.score = this.context.score + score;\r\n        if (this.context.score >= this.context.levelSetting.levelUpScore && this.context.levelSetting.levelUpScore > 0) {\r\n            this.currentLevelIndex++;\r\n        }\r\n        if (this.currentLevelIndex < this.gameLevels.length) {\r\n            this.changeGameLevel(this.currentLevelIndex);\r\n        }\r\n    }\r\n\r\n    changeGameLevel(levelIndex: number) {\r\n        let levelPrefab = this.gameLevels[levelIndex];\r\n        let level = instantiate(levelPrefab).getComponent(GameLevel);\r\n        this.context.useGameLevel(level);\r\n        this.bg.getComponent(bg).setBackGroundFrame(level.gameBgSpriteFrame);\r\n    }\r\n\r\n    pauseGame() {\r\n\r\n        this.context.gameStatus = GameStatus.Pause;\r\n        Dialog.show(\"\", \"\", [\r\n            {\r\n                label: \"\", action: (e: EventTouch, dialog: Dialog) => {\r\n                    this.context.gameStatus = GameStatus.Over;\r\n                    director.loadScene(\"home\");\r\n                }\r\n            },\r\n            {\r\n                label: \"\", action: (e: EventTouch, dialog: Dialog) => {\r\n                    this.context.gameStatus = GameStatus.Playing;\r\n                }\r\n            }\r\n        ]);\r\n    }\r\n    endGame() {\r\n        this.context.gameStatus = GameStatus.Over;\r\n        //TODO: move to gameManager handler\r\n        let newScore = this.context.score;\r\n        let lastScoreNaN = parseInt(sys.localStorage.getItem(\"lastScore\"));\r\n        let maxScoreNaN = parseInt(sys.localStorage.getItem(\"maxScore\"));\r\n        let lastScore = isNaN(lastScoreNaN) ? 0 : lastScoreNaN;\r\n        let maxScore = isNaN(maxScoreNaN) ? 0 : maxScoreNaN;\r\n        maxScore = Math.max(maxScore, newScore);\r\n        sys.localStorage.setItem(\"lastScore\", newScore.toString());\r\n        sys.localStorage.setItem(\"maxScore\", maxScore.toString());\r\n        let randomIndex = Math.floor(Math.random() * this.context.presetMessages.length);\r\n        Dialog.show(\"\", this.context.presetMessages[randomIndex]\r\n            + \"\\n\\n\" + newScore\r\n            //+ \"\\n\" + lastScore\r\n            + \"\\n\" + maxScore, [\r\n            {\r\n                label: \"\", action: (e: EventTouch, dialog: Dialog) => {\r\n                    director.loadScene(\"home\");\r\n                }\r\n            },\r\n            {\r\n                label: \"\", action: (e: EventTouch, dialog: Dialog) => {\r\n                    director.loadScene(\"gameplay\");\r\n                }\r\n            }\r\n        ]);\r\n    }\r\n    start() {\r\n        // this.schedule(() => {\r\n        //     if (this.context.gameStatus == GameStatus.Playing) {\r\n        //         if (this.context.enemyShootThreshold > 0)\r\n        //             this.context.enemyShootThreshold = this.context.enemyShootThreshold - 0.01;\r\n\r\n        //         if (this.context.enemyInterval > 0.5)\r\n        //             this.context.enemyInterval = this.context.enemyInterval - 0.01;\r\n        //     }\r\n        // }, 1);\r\n        this.player.getComponent(Player).destoryCallback = (sender: Player) => {\r\n            this.endGame();\r\n        }\r\n        this.currentLevelIndex = this.beginGameLevelIndex;\r\n        this.changeGameLevel(this.currentLevelIndex);\r\n        this.context.reset();\r\n        //enable physicssystem2d\r\n        PhysicsSystem2D.instance.enable = true;\r\n        if (this.isDebug) {\r\n            PhysicsSystem2D.instance.debugDrawFlags = EPhysics2DDrawFlags.All;\r\n        } else {\r\n            PhysicsSystem2D.instance.debugDrawFlags = EPhysics2DDrawFlags.None;\r\n        }\r\n        this.adjustLayout();\r\n        if (sys.isMobile) {\r\n            director.getScene().getComponentInChildren(Canvas).node.on(Node.EventType.TOUCH_MOVE, this.onTouchMoveOfCanvas, this);\r\n        }\r\n        else {\r\n            this.player.node.on(Node.EventType.TOUCH_MOVE, this.onMouseMoveOfPlayer, this);\r\n        }\r\n    }\r\n\r\n    //for mouse eviroment, pc, mac, web\r\n    onMouseMoveOfPlayer(e: EventTouch) {\r\n        //if game is not playing, then return\r\n        if (this.context.gameStatus != GameStatus.Playing && this.context.gameStatus != GameStatus.Start)\r\n            return;\r\n\r\n        if (this.beginingAnimation != null && this.beginingAnimationIsRunning) {\r\n            //console.log(\"beginingAnimationIsRunning\");\r\n            this.beginingAnimationIsRunning = false;\r\n            this.beginingAnimation.stop();\r\n            //this.player.node.setScale(1, 1);\r\n        }\r\n        //move the player to the touch position\r\n        if (this.player != null && this.player.node != null) {\r\n\r\n            // touchmove event.getLocation() world point\r\n            let uiposition = e.getUILocation();\r\n            //console.log(\"node point: \" + uiposition.x + \", \" + uiposition.y);\r\n            // herobackgroundworld pointnode point\r\n            let newUILocation =  this.player.node.parent.getComponent(UITransform).convertToNodeSpaceAR(v3(uiposition.x, uiposition.y, 0));\r\n            //console.log(\"player position: \" + this.node.position.x + \", \" + this.node.position.y);\r\n            //console.log(\"new Node location: \" + newUILocation.x + \", \" + newUILocation.y);\r\n            //if boundary out of screen, then stop move\r\n\r\n            let canvasSize = director.getScene().getComponentInChildren(Canvas).node.getComponent(UITransform).contentSize;\r\n            let playerSize = this.player.node.getComponent(UITransform).contentSize;\r\n            newUILocation.x = clamp(newUILocation.x, - canvasSize.width / 2 + playerSize.width / 2, canvasSize.width / 2 - playerSize.width / 2);\r\n            newUILocation.y = clamp(newUILocation.y, - canvasSize.height / 2 + playerSize.height / 2, canvasSize.height / 2 - playerSize.height / 2);\r\n\r\n            //set player position\r\n            this.player.node.setPosition(newUILocation);\r\n        }\r\n    }\r\n\r\n    onTouchMoveOfCanvas(e: EventTouch) {\r\n        //if game is not playing, then return\r\n        if (this.context.gameStatus != GameStatus.Playing && this.context.gameStatus != GameStatus.Start)\r\n            return;\r\n\r\n        if (this.beginingAnimation != null && this.beginingAnimationIsRunning) {\r\n            //console.log(\"beginingAnimationIsRunning\");\r\n            this.beginingAnimationIsRunning = false;\r\n            this.beginingAnimation.stop();\r\n            //this.player.node.setScale(1, 1);\r\n        }\r\n        //move the player to the touch position\r\n        if (this.player != null && this.player.node != null) {\r\n            let playerPos = this.player.node.position;\r\n            let delta = e.getDelta();\r\n\r\n            var newX = playerPos.x + delta.x / 2;\r\n            var newY = playerPos.y + delta.y / 2;\r\n            let canvasSize = director.getScene().getComponentInChildren(Canvas).node.getComponent(UITransform).contentSize;\r\n            let playerSize = this.player.node.getComponent(UITransform).contentSize;\r\n\r\n            newX = clamp(newX, - canvasSize.width / 2 + playerSize.width / 2, canvasSize.width / 2 - playerSize.width / 2);\r\n            newY = clamp(newY, - canvasSize.height / 2 + playerSize.height / 2, canvasSize.height / 2 - playerSize.height / 2);\r\n            this.player.node.setPosition(newX, newY);\r\n\r\n        }\r\n    }\r\n    //back to home scene\r\n    onBackBtnClick(e: EventTouch) {\r\n        //if game is pause, then return\r\n        if (this.context.gameStatus == GameStatus.Start || this.context.gameStatus == GameStatus.Playing) {\r\n            this.pauseGame();\r\n        }\r\n        //director.loadScene(\"home\");\r\n    }\r\n\r\n    cloneNode() {\r\n    }\r\n\r\n    renderAwards() {\r\n        if (this.weaponTypes.length > 0) {\r\n            //render awards randomly every 5 seconds from this.awardTypes\r\n            let randomIndex = Math.round(Math.random() * (this.weaponTypes.length - 1));\r\n            let awardPrefab = this.weaponTypes[randomIndex];\r\n            let award = instantiate(awardPrefab);\r\n            let awardObj = award.getComponent(YMoveable);\r\n            awardObj.speed = 200;\r\n            awardObj.direction = MoveDirection.MoveDown;\r\n            let canvas = director.getScene().getComponentInChildren(Canvas).node;\r\n            //get screen\r\n            let screen = canvas.getComponent(UITransform).contentSize;\r\n            //set award in random x position, and set y position to screen top, and must bound within award size\r\n            let awardWidth = award.getComponent(UITransform).contentSize.width;\r\n            let awardHeight = award.getComponent(UITransform).contentSize.height;\r\n            //random x between -1/2 screen width to 1/2 screen width\r\n            let awardX = Math.random() * (screen.width - awardWidth) - (screen.width - awardWidth) / 2;\r\n            let awardY = (screen.height - awardHeight) / 2;\r\n            //set award position\r\n            award.setPosition(awardX, awardY);\r\n            //add award to scene\r\n            award.parent = canvas;\r\n            award.active = true;\r\n        }\r\n    }\r\n\r\n    //render enemies\r\n    renderEnemies() {\r\n        //get enemy prefab\r\n        //instantiate enemy prefab\r\n        let enemy = instantiate(this.enemyPrefab);\r\n        let enemyObj = enemy.getComponent(Enemy);\r\n        //random enemy speed [200, 500]\r\n        enemyObj.speed = Math.random() * this.context.levelSetting.enemySpeed + this.context.levelSetting.enemySpeed;\r\n\r\n        enemyObj.direction = MoveDirection.MoveDown;\r\n        enemyObj.destoryCallback = (sender: Enemy) => {\r\n            this.scoreAdd();\r\n        }\r\n\r\n        enemyObj.bulletInterval = this.context.levelSetting.enemyShootInterval;\r\n        //set bullet damage\r\n        //enemyObj.bulletDamage = this.context.levelSetting.enemyShootDamage;\r\n        enemyObj.bulletSpeed = Math.random() * this.context.levelSetting.enemyShootSpeed + 50;\r\n        enemyObj.target = this.player;\r\n        let canvas = director.getScene().getComponentInChildren(Canvas).node;\r\n        //get screen\r\n        let screen = canvas.getComponent(UITransform).contentSize;\r\n        //set enemy in random x position, and set y position to screen top, and must bound within enemy size\r\n        let enemyWidth = enemy.getComponent(UITransform).contentSize.width;\r\n        let enemyHeight = enemy.getComponent(UITransform).contentSize.height;\r\n        //random x between -1/2 screen width to 1/2 screen width\r\n        let enemyX = Math.random() * (screen.width - enemyWidth) - (screen.width - enemyWidth) / 2;\r\n        let enemyY = (screen.height - enemyHeight) / 2;\r\n        //set enemy position\r\n        enemy.setPosition(enemyX, enemyY);\r\n        //add enemy to scene\r\n        enemy.parent = canvas;\r\n        enemy.active = true;\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        const score = this.context.score;\r\n        const levelUpScore = this.context.levelSetting.levelUpScore;\r\n        const level = this.context.levelSetting.level;\r\n        const levelName = this.context.levelSetting.levelName;\r\n        this.lblScore.getComponent(Label).string = \" \" + level + \"  \" + score + (levelUpScore > 0 ? \"  \" + levelUpScore : \"\");\r\n\r\n        //if game is pause, then return\r\n        if (this.context.gameStatus == GameStatus.Playing) {\r\n            //render enemies every 1 second\r\n            if (this.context.shouldCreateEnemy(deltaTime)) {\r\n                this.renderEnemies();\r\n            }\r\n            //render awards every 5 seconds\r\n            if (this.context.shouldCreateAward(deltaTime)) {\r\n                this.renderAwards();\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n","declare let wx: any;\r\n\r\nimport { _decorator,sys, Component, Node, Button, director, Canvas , UITransform, EventTouch} from 'cc';\r\nconst { ccclass, property } = _decorator;\r\n\r\n@ccclass('home')\r\nexport class home extends Component {\r\n    @property(Node)\r\n    private bg: Node = null;\r\n    @property(Button)\r\n    private startButton: Button = null;\r\n\r\n    start() {\r\n\r\n    }\r\n\r\n    protected onLoad(): void {\r\n        let contentSize = director.getScene().getComponentInChildren(Canvas).getComponent(UITransform).contentSize;\r\n        this.bg.getComponent(UITransform).setContentSize(contentSize);\r\n        this.startButton.node.on(Node.EventType.TOUCH_END, this.onStartButtonClick, this);\r\n    }\r\n\r\n    private onStartButtonClick(e:EventTouch): void {\r\n\r\n        //check if wechat plafform\r\n        // if (sys.platform === sys.Platform.WECHAT_GAME) {\r\n        //     wx.shareAppMessage({\r\n        //       title: '',\r\n        //       imageUrl: 'URL',\r\n        //       success: function () {\r\n        //         console.log('');\r\n        //       },\r\n        //       fail: function () {\r\n        //         console.log('');\r\n        //       }\r\n        //     });\r\n        //   }\r\n\r\n        director.loadScene(\"gameplay\");\r\n    }\r\n\r\n    update(deltaTime: number) {\r\n        \r\n    }\r\n}\r\n\r\n"]}